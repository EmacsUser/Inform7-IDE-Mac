!! Processing.i6: code for processing rules and rulebooks

! The rule change stack contains 3-word (6 byte) records,
! defined thus in code generated by codegen.c:
! Constant RS_CAPACITY = 999;
! Global   rulechange_sp = 0;
! Array    rulechange_stack --> RS_CAPACITY;

[ PushRuleChange usage rule1 rule2;
  if (rulechange_sp >= RS_CAPACITY) {
      print "*** Rule change stack exhausted ***^^";
  }
  rulechange_stack-->rulechange_sp++ = usage;
  rulechange_stack-->rulechange_sp++ = rule1;
  rulechange_stack-->rulechange_sp++ = rule2;
];

! The first word of each record indicates a type, of which
! one value is special and indicates the start of a "follow"
! frame:

Constant RS_FRAME = -1;

! We also need to know the internal number of the procedural
! rulebook (which must correspond to that in the I7 source):

Constant APROC_RB = 0;
Constant AFTER_RB = 3;
Constant PROC_RB = 4;
Constant ACCESS_RB = 5;
Constant REACHIN_RB = 10;
Constant REACHOUT_RB = 11;
Constant TURNEND_RB = 9;
Constant GAME_BEGINS_RB = 22;
Constant GAME_ENDS_RB = 23;

! To "follow" a rulebook, we start a new frame, process the
! procedural rules, then process the rulebook, then clear
! the frame back off the stack:

[ BeginFollowRulebook;
  PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
  ProcessRulebook(PROC_RB);
];
[ EndFollowRulebook;
  while ((rulechange_sp > 0) && 
      (rulechange_stack-->rulechange_sp ~= RS_FRAME))
      rulechange_sp = rulechange_sp - 3;
  if (rulechange_sp > 0) rulechange_sp = rulechange_sp - 3;
];
[ FollowRulebook rulebook par;
  if (rulebook == PROC_RB) rfalse;
  BeginFollowRulebook();
  ProcessRulebook(rulebook, par);
  EndFollowRulebook();
];

! The rule changes pushed on to the stack have the following
! type numbers:

Constant RS_DONOTRUN   = 1;
Constant RS_RUN        = 2;
Constant RS_MOVEBEFORE = 3;
Constant RS_MOVEAFTER  = 4;
Constant RS_DONOTUSE   = 5;
Constant RS_USE        = 6;
Constant RS_SUBSTITUTE = 7;
Constant RS_SUCCEEDS   = 8;
Constant RS_FAILS      = 9;

! A variable logging the depth of recursion of rulebook
! processing, which at present is used only to print neatly
! formatted debugging:

Global process_rulebook_count;

! The main rulebook processing routine is
!   ProcessRulebook(rulebook/rule)
! which returns true if the rulebook or rule chose to
! "succeed" or "fail", and false if it made no choice.
! In the event that a choice was made, the result is left
! as a record above the top of the stack, and should be
! collected immediately.

! The following bitmap is used in a simple state machine:

Constant RS_ACTIVE_BIT = 1;
Constant RS_MOVED_BIT = 2;
Constant RS_USERESULT_BIT = 4;

Constant NO_DEBUGGABLES = 4;
Array debuggable_rulebooks --> APROC_RB PROC_RB ACCESS_RB TURNEND_RB;
Array debuggable_states --> 0 0 0 0;
[ DebugRbSub i;
  if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
      debuggable_states-->noun = 1;
      for (i=0:i<NO_DEBUGGABLES:i++) print debuggable_states-->i;
      " - OK";
  }
  "0 = actions, 1 = procedural, 2 = accessibility, 3 = turn sequence";
];
[ DebugRbOffSub i;
  if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
      debuggable_states-->noun = 0;
      for (i=0:i<NO_DEBUGGABLES:i++) print debuggable_states-->i;
      " - OK";
  }
  "0 = actions, 1 = procedural, 2 = accessibility, 3 = turn sequence";
];
Global debugging_rules = 0;
[ AdjustDbr s i;
  for (i=0:i<NO_DEBUGGABLES:i++) {
      if (s == debuggable_rulebooks-->i) {
          debugging_rules = debuggable_states-->i;
      }
  }
];
Verb "dbr"
	* number -> DebugRb
	* number "off" -> DebugRbOff;

[ ProcessRulebook rulebook par ignore_movements
  i rv bits x frame_base substituted_rule usage rule1 rule2 sdbr posthumous;
  if (rulebook == GAME_ENDS_RB) posthumous = true;
  if (par) parameter_object = par;
  for (x = rulechange_sp-3: x>=0: x = x - 3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
      ! print x, ": US ", usage, " r1 ", rule1, " r2 ", rule2, "^";
      if (usage == RS_FRAME) { x=x+3; break; }
      if ((usage == RS_MOVEBEFORE) && (rule1 == rulebook))
          bits = bits | (RS_MOVED_BIT);
      if ((usage == RS_MOVEAFTER) && (rule1 == rulebook))
          bits = bits | (RS_MOVED_BIT);
  } if (x<0) x=0; frame_base = x;
  if ((bits & RS_MOVED_BIT) && (ignore_movements == false)) { rfalse; }
  bits = bits | RS_ACTIVE_BIT;
  bits = bits | RS_USERESULT_BIT;
  substituted_rule = rulebook;
  for (: x<rulechange_sp: x = x + 3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
      if ((usage == RS_DONOTRUN) && (rule1 == rulebook))
          bits = bits & (~RS_ACTIVE_BIT);
      if ((usage == RS_RUN) && (rule1 == rulebook))
          bits = bits | (RS_ACTIVE_BIT);
      if ((usage == RS_DONOTUSE) && (rule1 == rulebook))
          bits = bits & (~RS_USERESULT_BIT);
      if ((usage == RS_USE) && (rule1 == rulebook))
          bits = bits | (RS_USERESULT_BIT);
      if ((usage == RS_SUBSTITUTE) && (rule1 == rulebook))
          substituted_rule = rule2;
      if ((usage == RS_MOVEBEFORE) && (rule2 == rulebook)) {
           rv = ProcessRulebook(rule1, par, true);
           if (rv) { return rv; }
      }
  } !print "Bits: ", bits, "^";
  if ((bits & RS_ACTIVE_BIT) == 0) { rfalse; }
  sdbr = debugging_rules;
  AdjustDbr(substituted_rule); if (debugging_rules) DebugRulebooks(substituted_rule, par);
  ! (A routine defined in the I7 code generator)
  process_rulebook_count = process_rulebook_count + debugging_rules;
  if (substituted_rule < 256) {
      substituted_rule = rulebooks_array-->substituted_rule;
      for (i=0, rv=0: (substituted_rule-->i~=$ffff) && ((posthumous) || (deadflag==false)): i++)
          if ((rv = (ProcessRulebook(substituted_rule-->i, par)))
              && (bits & RS_USERESULT_BIT)) break;
  } else rv = indirect(substituted_rule);
  if (rv && (bits & RS_USERESULT_BIT)) {
      AdjustDbr(substituted_rule);
  	  process_rulebook_count = process_rulebook_count - debugging_rules;
  	  if (process_rulebook_count < 0) process_rulebook_count = 0;
  	  if (debugging_rules) {
	      spaces(2*process_rulebook_count);
    	  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
    	      print "[stopped: success]^";
    	  if (rulechange_stack-->rulechange_sp == RS_FAILS)
    	      print "[stopped: fail]^";
      }
      debugging_rules = sdbr;
      return rv;
  }
  for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
      if ((usage == RS_MOVEAFTER) && (rule2 == rulebook)) {
          rv = ProcessRulebook(rule1, par, true);
          if (rv) { process_rulebook_count--;
              debugging_rules = sdbr;
      	      return rv;
      	  }
      }
  }
  process_rulebook_count = process_rulebook_count - debugging_rules;
  rulechange_stack-->rulechange_sp = 0;
  debugging_rules = sdbr;
  rfalse;
];

! The following routines provide a sort of rule-changing API:

[ ResultOfRule a;
  a = rulechange_stack-->rulechange_sp;
  if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
      a = rulechange_stack-->(rulechange_sp + 1);
      if (a) return rulechange_stack-->(rulechange_sp + 2);
  }
  rfalse;
];

[ RulebookSucceeds valueflag value;
  PushRuleChange(RS_SUCCEEDS, valueflag, value);
  rulechange_sp = rulechange_sp - 3;
];
[ RulebookFails valueflag value;
  PushRuleChange(RS_FAILS, valueflag, value);
  rulechange_sp = rulechange_sp - 3;
];
[ SuppressRule rule;
  PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule;
  PushRuleChange(RS_RUN, rule, 0);
];
[ DonotuseRule rule;
  PushRuleChange(RS_DONOTUSE, rule, 0);
];
[ UseRule rule;
  PushRuleChange(RS_USE, rule, 0);
];
[ SubstituteRule rule1 rule2;
  PushRuleChange(RS_SUBSTITUTE, rule2, rule1);
];
[ MoveRuleBefore rule1 rule2;
  PushRuleChange(RS_MOVEBEFORE, rule1, rule2);
];
[ MoveRuleAfter rule1 rule2;
  PushRuleChange(RS_MOVEAFTER, rule1, rule2);
];

! Hooks to the I6 library:

[ BeginActionProcessing;
  BeginFollowRulebook();
];
[ EndActionProcessing;
  EndFollowRulebook();
];

! Replaced from the I6 library:

Global untouchable_object;
[ ObjectIsUntouchable item flag1 flag2;
  untouchable_object = item;
  if (ProcessRulebook(ACCESS_RB)) {
      if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
          rfalse; ! No barrier
      } else {
          rtrue; ! Barrier
      }
  }
  ! No decision is interpreted as no barrier to access:
  rfalse;
];

[ OIU_Scoped i;
  i = ObjectScopedBySomething(untouchable_object);
  if (i ~= 0) return ObjectIsUntouchable(i);
  rfalse;
];

[ OIU_Barrier ancestor i;
  ancestor = CommonAncestor(player, untouchable_object);

  ! First, a barrier between the player and the ancestor.

  if (player ~= ancestor) {
      i = parent(player);
      while (i~=ancestor && i) {
          if (ProcessRulebook(REACHOUT_RB, i)) {
              if (rulechange_stack-->rulechange_sp == RS_FAILS) {
                  rtrue; ! Barrier
              }
          }
          i = parent(i);
      }
  }

  ! Second, a barrier between the item and the ancestor.

  if (untouchable_object ~= ancestor)
  {   i = parent(untouchable_object);
      while (i~=ancestor && i) {
          if (ProcessRulebook(REACHIN_RB, i)) {
              if (rulechange_stack-->rulechange_sp == RS_FAILS) {
                  rtrue; ! Barrier
              }
          }
          i = parent(i);
      }
  }

  RulebookSucceeds(); ! No barrier
  rtrue;
];

[ OIUB_CCI;
  if (parameter_object has container && parameter_object hasnt open) {
      L__M(##Take,9,parameter_object);
      RulebookFails();
      rtrue;
  }
  rfalse;
];

[ OIUB_CCO;
  if (parameter_object has container && parameter_object hasnt open) {
      L__M(##Take,9,parameter_object);
      RulebookFails();
      rtrue;
  }
  rfalse;
];

[ OIUB_AP;
  if (parameter_object has container) rfalse;
  if (parameter_object has supporter) rfalse;
  if (action == ##Take or ##Remove or ##Transfer) {
  if (parameter_object has animate) {
      L__M(##Take,6,parameter_object);
      RulebookFails();
      rtrue;
  }
  }
  rfalse;
];

[ OIUB_CP;
  if (parameter_object has container) rfalse;
  if (parameter_object has supporter) rfalse;
  if (action == ##Take or ##Remove or ##Transfer) {
  if (parameter_object has transparent) {
      L__M(##Take,7,parameter_object);
      RulebookFails();
      rtrue;
  }
  L__M(##Take,8,parameter_object);
  RulebookFails();
  rtrue;
  }
  rfalse;
];

[ TS1_R; AdvanceWorldClock(); rfalse; ];
[ TS2_R; RunTimersAndDaemons(); rfalse; ];
[ TS3_R; RunEachTurnProperties(); rfalse; ];
[ TS4_R; TimePasses(); rfalse; ];
[ TS5_R; AdjustLight(); rfalse; ];
[ TS6_R obj; NoteObjectAcquisitions();
  objectloop (obj in player)
      if (obj ofclass RUCKSACK_CLASS)
          SACK_OBJECT = obj;
  rfalse; ];

[ TestActionBitmap obj act i j k;
  if (obj == nothing) return ((ActionHappened->j) ~= 0);
  if (~~(obj provides action_bitmap)) rfalse;
  ! for (i=0; i<10; i++) print (obj.&action_bitmap)->i, " ";
  for (i=0, k=1; i<ActionCount; i++) {
      if (act == ActionCoding-->i) {
          return ((((obj.&action_bitmap)->j) & k) ~= 0);
      }
      k = k*2; if (k == 256) { k = 1; j++; }
  }
  rfalse;
];
[ SetActionBitmap obj act i j k;
  for (i=0, k=1; i<ActionCount; i++) {
      if (act == ActionCoding-->i) {
          if ((obj) && (obj provides action_bitmap)) {
      		  (obj.&action_bitmap)->0 =
                   ((obj.&action_bitmap)->0) | 1;
      		  (obj.&action_bitmap)->j =
                   ((obj.&action_bitmap)->j) | k;
              return;
          }
          ActionHappened->0 = (ActionHappened->0) | 1;
          ActionHappened->j = (ActionHappened->j) | k;
      }
      k = k*2; if (k == 256) { k = 1; j++; }
  }
];
[ ActionPrimitive sa sn mf mt mb mth;
  sa = action; sn = noun; mf = move_from; mt = move_to;
  mb = move_by; mth = move_through;
  self = noun;
  if (action == ##Answer) noun = second;
  if (action == ##Consult or ##Ask or ##Tell or ##NotUnderstood or ##Answer) {
      inp2 = 1; second = consult_from + 256*consult_words;
  }
  if (action == ##Go) {
      move_from = real_location; move_to = nothing;
      move_by = nothing; move_through = nothing;
      if ((parent(player) has container) && (parent(player) has enterable))
          move_by = parent(player);
      if (noun in compass) {
          move_to = move_from.(noun.door_dir);
      } else {
          if (noun has door) move_to = noun;
      }
      if ((move_to ~= nothing) && (move_to has door)) {
          move_through = move_to;
          move_to = move_to.door_to();
      }
      #IFDEF DEBUG;
      if (debug_flag & 2 ~= 0) {
          print "[Go with move_from = ";
          if (move_from) print (the) move_from; else print "nowhere";
          print ", move_to = ";
          if (move_to) print (the) move_to; else print "nowhere";
          print ", move_by = ";
          if (move_by) print (the) move_by; else print "nothing";
          print ", move_through = ";
          if (move_through) print (the) move_through; else print "nothing";
          print ", move_pushing = ";
          if (move_pushing) print (the) move_pushing; else print "nothing";
          print "]^";
      }
      #ENDIF;
  }
  TrackActions();
  ProcessRulebook(APROC_RB);
  #IFDEF DEBUG;
  if (debug_flag & 2 ~= 0) {
      switch (rulechange_stack-->rulechange_sp) {
          RS_SUCCEEDS: print "[Action succeeded]^";
          RS_FAILS: print "[Action failed]^";
          default: print "[Action ended without result]^";
      }
  }
  #ENDIF;
  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
      SetActionBitmap(noun, action);
      if (action == ##Go) SetActionBitmap(location, ##Enter);
  }
  EndActionProcessing();
  move_from = mf; move_to = mt; action = sa; noun = sn;
  move_by = mb; move_through = mth;
];
[ GenericVerbSub ch co re;
  if (ProcessRulebook(ch)) { RulebookFails(); rtrue; }
  if (ProcessRulebook(co)) jump HappyEnding;
  if (keep_silent) jump HappyEnding;
  if (ProcessRulebook(AFTER_RB)) jump HappyEnding;
  ProcessRulebook(re);
  .HappyEnding; RulebookSucceeds(); rtrue;
];
[ AllowPushDir i;
  if (parent(second)~=compass) return L__M(##PushDir,2,noun);
  if (second==u_obj or d_obj)  return L__M(##PushDir,3,noun);
  AfterRoutines(); i=noun; move i to player; move_pushing = i;
  <Go second>;
  move_pushing = nothing;
  if (location==thedark) move i to real_location;
  else move i to location;
];
[ SetI7Timer R t f i b;
  for (i=1: i<=(I7TimerTable-->0): i++) {
      if (R == I7TimerTable-->i) { b=i; jump SlotFound; }
      if ((b==0) && (I7TimerTable-->i == 0)) b=i;
  }
  if (b==0) ">--> Too many timed events are going on at once.";
  .SlotFound;
  I7TimerTable-->b = R;
  if (f == 0) I7TimerTableTimes-->b = -t;
  else I7TimerTableTimes-->b = t;
];
[ ProcessI7Timers i t f r;
  for (i=1: i<=(I7TimerTable-->0): i++)
      if ((r=I7TimerTable-->i) ~= 0) {
          t = I7TimerTableTimes-->i; f = 0;
          if (t<0) {
              (I7TimerTableTimes-->i)++;
              if (I7TimerTableTimes-->i == 0) f=1;
          } else {
              if ((the_time >= t) && (the_time < t+30)) f=1;
          }
          if (f) {
              I7TimerTable-->i = 0;
              ProcessRulebook(r);
          }
      }
  rfalse;
];
[ SetDaemonRule d s i j;
  j = daemonic_rules-->0;
  for (i=1: i<=j: i++) {
      if (daemonic_rules-->i == d) {
          daemon_activity->(i-1) = s;
          return;
      }
  }
  ">--> You tried to start or stop a rule which was not a daemon.";
];
[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];
[ PrintTimeOfDay t aop;
  if (t<0) { print "<no time>"; return; }
  if (t >= 60*12) { aop = "pm"; t=t-60*12; } else aop = "am";
  print t/60, ":";
  if (t%60<10) print "0"; print t%60, " ", (string) aop;
];
[ PrintTimeOfDayEnglish t h m dir aop;
  h = (t/60) % 12; m = t%60; if (h==0) h=12;
  if (m==0) { print (number) h, " o'clock"; return; }
  dir = "past";
  if (m > 30) { m = 60-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
  switch(m) {
  	15: print "quarter"; 30: print "half";
  	default: print (number) m; if (m%5 ~= 0) print " minutes"; }
  print " ", (string) dir, " ", (number) h;
];
[ PermitAttributeR obj off i;
  ! print "Asking permission of ", (the) obj, "^";
  i=off; while (property_metadata-->i >= 0) {
  if (obj == property_metadata-->i) rtrue; i++; }
  rfalse; ];
[ PermitAttribute f obj att off textual i a l; if (att<0) att = ~att;
  if (metaclass(obj) ~= Object) rfalse;
  if (f) off = attribute_offsets-->att; else off = property_offsets-->att;
  if (off<0) {
  print ">--> Bad property on ", (the) obj, "^"; rtrue; }
  textual = property_metadata-->off; off++;
  if (PermitAttributeR(obj, off)) jump Okay;
  if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
  for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
  print ">--> Since ", (the) obj, " is not allowed the property ~",
      (string) textual, "~, it is against the rules to try to use it.^";
  rfalse;
  .Okay; if (f) rtrue;
  if (obj provides att) rtrue;
  print ">--> Although ", (the) obj, " is allowed to have the property ~",
      (string) textual, "~, no value was ever given, so it can't now be used.^";
  rfalse; ];
[ AccessProp obj pr;
  if (PermitAttribute(false, obj, pr)) return obj.pr;
  rfalse; ];
[ WriteAccessProp obj pr val;
  if (PermitAttribute(false, obj, pr)) obj.pr = val; ];
