! Waiting

[ WaitSub_R1; return L__M(##Wait,1,noun); ];

! The inventory

[ InvSub_O1;
  if (inventory_style==0)
  	inventory_style = FULLINV_BIT + INDENT_BIT + NEWLINE_BIT + RECURSE_BIT;
  rfalse; ];
[ InvSub_O2;
  if (child(player)==0) return L__M(##Inv,1); rfalse;
];
[ InvSub_O3;
  L__M(##Inv,2);
  if (inventory_style & NEWLINE_BIT ~= 0) print ":^"; else print " ";
  WriteListFrom(child(player), inventory_style, 1);
  if (inventory_style & ENGLISH_BIT ~= 0) print ".^";
  rfalse;
];
[ InvSub_O4 x;
#IFNDEF MANUAL_PRONOUNS;
  objectloop(x in player) PronounNotice(x);
#ENDIF;
  x = 0; ! To prevent a "not used" error
  rfalse;
];

! Object movements

Global ac_common_ancestor;
Global take_after_recipient;
[ TakeSub_C1;
  if (onotheld_mode==1 && noun in player) {
      RulebookSucceeds(); rtrue; } rfalse; ];
[ TakeSub_C2;
  if (noun == player) return L__M(##Take,2); rfalse; ];
[ TakeSub_C3;
  if (noun has animate) return L__M(##Take,3,noun); rfalse; ];
[ TakeSub_C4 i;
  if (noun provides component_part_of)
      return L__M(##Take,7,noun.component_part_of);
  ac_common_ancestor = CommonAncestor(player, noun);
  if (ac_common_ancestor == 0) {
      i = ObjectScopedBySomething(noun);
      if (i ~= 0) ac_common_ancestor = CommonAncestor(player, i);
  } rfalse; ];
[ TakeSub_C5;
  if (ac_common_ancestor == 0) return L__M(##Take,8,noun); rfalse; ];
[ TakeSub_C6;
  if (ac_common_ancestor == noun) return L__M(##Take,4,noun); rfalse; ];
[ TakeSub_C7;
  if (noun in player) return L__M(##Take,5,noun); rfalse; ];
[ TakeSub_C8 i k;
  i=parent(noun); take_after_recipient = 0;
  if (i ~= ac_common_ancestor && (i has container || i has supporter))
  {   take_after_recipient=i;
      k=action; action=##LetGo;
      if (RunRoutines(i,before)~=0) { action=k; rtrue; }
      action=k;
  } rfalse; ];
[ TakeSub_C9;
  if (noun has scenery) return L__M(##Take,10,noun); rfalse; ];
[ TakeSub_C10;
  if (noun has static)  return L__M(##Take,11,noun); rfalse; ];
[ TakeSub_C11 j k;
  if (SACK_OBJECT == nothing || SACK_OBJECT notin player) rfalse;
  k=0; objectloop (j in player) if (j hasnt worn) k++;
  if (k >= ValueOrRun(player,capacity)) {
      j=0;
      objectloop (k in player) 
          if (k~=SACK_OBJECT && k hasnt worn && k hasnt light) j=k;
      if (j~=0) {
          L__M(##Take,13,j);
          keep_silent = 1; <Insert j SACK_OBJECT>; keep_silent = 0;
          if (j notin SACK_OBJECT) rtrue;
          rfalse;
      }
  } rfalse; ];
[ TakeSub_C12 j k;
  k=0; objectloop (j in player) if (j hasnt worn) k++;
  if (k >= ValueOrRun(player,capacity)) return L__M(##Take,12);
  rfalse; ];
[ TakeSub_O1; move noun to player; rfalse; ];
[ TakeSub_O2 k;
  if (take_after_recipient) {
      k=action; action=##LetGo;
      if (RunRoutines(take_after_recipient,after)~=0) { action=k; rtrue; }
      action=k;
  } rfalse; ];
[ TakeSub_R1; notheld_mode=onotheld_mode;
  if (notheld_mode==1) { RulebookSucceeds(); rtrue; } rfalse; ];
[ TakeSub_R2; L__M(##Take,1); ];

[ RemoveSub_C1 i;
  i=parent(noun);
  if (i has container && i hasnt open) return L__M(##Remove,1,noun);
  rfalse; ];
[ RemoveSub_C2 i;
  i=parent(noun); if (i~=second) return L__M(##Remove,2,noun);
  rfalse; ];
[ RemoveSub_C3 i;
  i=parent(noun); if (i has animate) return L__M(##Take,6,i);
  rfalse; ];

[ RemoveSub_O2; action=##Take; if (AfterRoutines()==1) {
  action=##Remove; rtrue; } action=##Remove; rfalse; ];
[ RemoveSub_R1; return L__M(##Remove,3,noun); ];

[ DropSub_C1;
  if (noun == player) return L__M(##PutOn, 4); rfalse; ];
[ DropSub_C2;
  if (noun in parent(player)) return L__M(##Drop,1,noun); rfalse; ];
[ DropSub_C3;
  if (noun notin player) return L__M(##Drop,2,noun); rfalse; ];
[ DropSub_C4;
  if (noun has worn) { L__M(##Drop,3,noun); <Disrobe noun>;
      if (noun has worn && noun in player) rtrue;
  } rfalse; ];
[ DropSub_O1; move noun to parent(player); give noun ~worn; rfalse; ];
[ DropSub_R1; return L__M(##Drop,4,noun); ];

[ PutOnSub_C1;
  if (second == d_obj || player in second) <<Drop noun>>; rfalse; ];
[ PutOnSub_C2;
  if (parent(noun)~=player) return L__M(##PutOn,1,noun); rfalse; ];
[ PutOnSub_C3;
  ac_common_ancestor = CommonAncestor(noun, second);
  if (ac_common_ancestor == noun) return L__M(##PutOn,2,noun); rfalse; ];
[ PutOnSub_C4;
  if (second ~= ac_common_ancestor)
  {   action=##Receive; receive_action=##PutOn;
      if (RunRoutines(second,before)~=0) { action=##PutOn; return; }
      action=##PutOn;
  } rfalse; ];
[ PutOnSub_C5;
  if (second hasnt supporter) return L__M(##PutOn,3,second); rfalse; ];
[ PutOnSub_C6;
  if (ac_common_ancestor == player) return L__M(##PutOn,4); rfalse; ];
[ PutOnSub_C7;
  if (noun has worn) { L__M(##PutOn,5,noun); <Disrobe noun>;
      if (noun has worn) rtrue; } rfalse; ];
[ PutOnSub_C8;
  if (children(second)>=ValueOrRun(second,capacity))
      return L__M(##PutOn,6,second); rfalse; ];
[ PutOnSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ PutOnSub_O2;
  if (second ~= ac_common_ancestor)
  {   action=##Receive;
      if (RunRoutines(second,after)~=0) { action=##PutOn; return; }
      action=##PutOn;
  } rfalse; ];
[ PutOnSub_R1;
  if (multiflag==1) return L__M(##PutOn,7);
  return L__M(##PutOn,8,noun); ];

[ InsertSub_C1;
  if (second==d_obj || player in second) <<Drop noun>>; rfalse; ];
[ InsertSub_C2;
  if (parent(noun)~=player) return L__M(##Insert,1,noun); rfalse; ];
[ InsertSub_C3;
  ac_common_ancestor = CommonAncestor(noun, second);
  if (ac_common_ancestor == noun) return L__M(##Insert, 5, noun); rfalse; ];
[ InsertSub_C4;
  if (second ~= ac_common_ancestor) {
      action=##Receive; receive_action = ##Insert;
      if (RunRoutines(second,before)~=0) { action=##Insert; rtrue; }
      action=##Insert;
  } rfalse; ];
[ InsertSub_C5;
  if (second ~= ac_common_ancestor) {
      if (second has container && second hasnt open)
          return L__M(##Insert,3,second);
  } rfalse; ];
[ InsertSub_C6;
  if (second hasnt container) return L__M(##Insert,2,second); rfalse; ];
[ InsertSub_C7;
  if (noun has worn) {
      L__M(##Insert,6,noun); <Disrobe noun>; if (noun has worn) rtrue;
  } rfalse; ];
[ InsertSub_C8;
  if (children(second) >= ValueOrRun(second,capacity))
      return L__M(##Insert,7,second); rfalse; ];
[ InsertSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ InsertSub_O2;
  if (second ~= ac_common_ancestor) {
      action=##Receive;
      if (RunRoutines(second,after)~=0) { action=##Insert; rtrue; }
      action=##Insert;
  } rfalse; ];
[ InsertSub_R1;
  if (multiflag==1) return L__M(##Insert,8,noun);
  L__M(##Insert,9,noun); rfalse; ];

! Actions involving movement of the player

[ EnterSub_C1;
  if (noun has door) <<Go noun>>; rfalse; ];
[ EnterSub_C2;
  if (noun in compass) <<Go noun>>; rfalse; ];
[ EnterSub_C3;
  if (player in noun) return L__M(##Enter,1,noun); rfalse; ];
[ EnterSub_C4;
  if (noun hasnt enterable) return L__M(##Enter,2,noun); rfalse; ];
[ EnterSub_C5;
  if (noun has container && noun hasnt open) return L__M(##Enter,3,noun);
  rfalse; ];
[ EnterSub_C6;
  ac_common_ancestor = CommonAncestor(player, noun); rfalse; ];
[ EnterSub_C7;
  if (ac_common_ancestor == player) return L__M(##Enter,4,noun);
  rfalse; ];
[ EnterSub_C8 i j k;
  if (parent(player) ~= parent(noun)) {
      while (player notin ac_common_ancestor)
      {   j = parent(player);
          k = keep_silent; 
          if (parent(j) ~= ac_common_ancestor || noun ~= ac_common_ancestor)
          {   L__M(##Enter,6,j);
              keep_silent = 1;
          }
          <Exit>;
          keep_silent = k;
          if (player in j) return;
      }
      if (player in noun) return;
      if (noun notin ac_common_ancestor)
      {   j = parent(noun);
          while (parent(j) ~= ac_common_ancestor) j = parent(j);
          L__M(##Enter,7,j);
          k = keep_silent; keep_silent = 1;
          <Enter j>;
          keep_silent = k;
          if (player notin j) return;
          <<Enter noun>>;
      }
  } rfalse;
];
[ EnterSub_O1; move player to noun; rfalse; ];
[ EnterSub_R1; L__M(##Enter,5,noun); rfalse; ];
[ EnterSub_R2; Locale(noun); rfalse; ];

[ ExitSub_C1;
  if (player in location ||
      (location==thedark && player in real_location)) {
      if ((parent(player)).out_to ~= 0) <<Go out_obj>>;
  } rfalse; ];
[ ExitSub_C2;
  if (player in location ||
      (location==thedark && player in real_location))
      return L__M(##Exit,1);
  rfalse; ];
[ ExitSub_C3 p;
  p=parent(player);
  if (p has container && p hasnt open) return L__M(##Exit,2,p);
  rfalse; ];
[ ExitSub_O1; noun = parent(player); move player to parent(noun); rfalse; ];
[ ExitSub_R1; L__M(##Exit,3,noun); rfalse; ];
[ ExitSub_R2; LookSub_P(1); rfalse; ];

[ GetOffSub_C1;
  if (player in noun) <<Exit>>; rfalse; ];
[ GetOffSub_C2; return L__M(##GetOff,1,noun); ];

Global go_to_location;
Global go_from_location;
Global go_with_vehicle;
Global go_dir_prop;
[ GoSub_C1; go_to_location = 0; go_from_location = location;
  go_with_vehicle = 0; go_dir_prop = 0;
  if (second ~= 0 && second notin Compass
      && ObjectIsUntouchable(second)) return;
  rfalse; ];
[ GoSub_C2 i j k; 
  i=parent(player);
  if ((location~=thedark && i~=location)
      || (location==thedark && i~=real_location)) {
      j=location;
      if (location==thedark) location=real_location;
      k=RunRoutines(i,before); if (k~=3) location=j;
      if (k==1) go_with_vehicle = i;
  } rfalse; ];
[ GoSub_C3 i;
  if (go_with_vehicle == nothing) {
      i=parent(player);
      if ((location~=thedark && i~=location)
          || (location==thedark && i~=real_location)) {
          return L__M(##Go,1,i);
      }
  } rfalse; ];

[ GoSub_C4;
  go_dir_prop=noun.door_dir;
  if (go_dir_prop ofclass Routine) go_dir_prop=RunRoutines(noun,door_dir);
  rfalse; ];

[ GoSub_C5 i;
  i = parent(player);
  if (go_with_vehicle) i = parent(go_with_vehicle);
  go_to_location=i.go_dir_prop; rfalse; ];

[ GoSub_C6;
  if (go_to_location ofclass String) {
      print (string) go_to_location; new_line; rtrue;
  } rfalse; ];

[ GoSub_C7  i;
  i = parent(player);
  if (go_with_vehicle) i = parent(go_with_vehicle);
  if (go_to_location ofclass Routine) {
      go_to_location = RunRoutines(i, go_dir_prop);
      if (go_to_location == true) rtrue;
  } rfalse; ];

[ GoSub_C8 i;
  i = parent(player);
  if (go_with_vehicle) i = parent(go_with_vehicle);
  if (go_to_location == nothing) {
      PrintOrRun(i, cant_go); rtrue; }
  rfalse; ];

[ GoSub_C9;
  if (go_to_location has door && go_to_location has concealed)
      return L__M(##Go,2); rfalse; ];
[ GoSub_C10;
  if (go_to_location has door && go_to_location hasnt open) {
      if (noun==u_obj) return L__M(##Go,3,go_to_location);
      if (noun==d_obj) return L__M(##Go,4,go_to_location);
      return L__M(##Go,5,go_to_location);
  } rfalse; ];
[ GoSub_C11 k;
  if (go_to_location has door) {
      k=RunRoutines(go_to_location,door_to);
      if (k==0) return L__M(##Go,6,go_to_location);
      if (k==1) rtrue;
      go_to_location = k;
  } rfalse; ];

[ GoSub_O1;
  if (go_with_vehicle==0) move player to go_to_location;
  else move go_with_vehicle to go_to_location;
  location=go_to_location; rfalse; ];
[ GoSub_O2; MoveFloatingObjects(); rfalse; ];
[ GoSub_O3 df;
  df=OffersLight(go_to_location);
  if (df~=0) { location=go_to_location; real_location=go_to_location; lightflag=1; }
  else
  {   if (go_from_location == thedark)
      {   DarkToDark();
          if (deadflag~=0) rtrue;
      }
      real_location=go_to_location;
      location=thedark; lightflag=0;
  } rfalse; ];

[ GoSub_R1; LookSub_P(1); rfalse; ];

! Actions involving sight

Global allow_abbreviated_look = 0;
Global visibility_levels;
[ LookSub_P allow_abbrev; allow_abbreviated_look = allow_abbrev;
  LookSub(); allow_abbreviated_look = 0; ];
[ LookSub_O1;
  if (parent(player)==0) return RunTimeError(10);
  visibility_levels = 0;
  .MovedByInitial;
  if (location == thedark) { visibility_ceiling = thedark; NoteArrival(); }
  else
  {   visibility_levels = FindVisibilityLevels();
      if (visibility_ceiling == location)
      {   NoteArrival();
          if (visibility_ceiling ~= location) jump MovedByInitial;
      }
  } rfalse;
];

[ LookSub_O2 i j;
  !   Printing the top line: e.g.
  !   Octagonal Room (on the table) (as Frodo)

  new_line;
  style bold;
  if (visibility_levels == 0) print (name) thedark;
  else
  {   if (visibility_ceiling ~= location) print (The) visibility_ceiling;
      else print (name) visibility_ceiling;
  }
  style roman;

  for (j=1, i=parent(player):j<visibility_levels:j++, i=parent(i))
      if (i has supporter) L__M(##Look,1,i);
                      else L__M(##Look,2,i);

  if (print_player_flag==1) L__M(##Look,3,player);
  new_line; rfalse;
];

[ LookSub_O3;
  if (lookmode<3 && visibility_ceiling==location)
  {   if ((allow_abbreviated_look~=1) || (lookmode==2) || (location hasnt visited))
      {   if (location.describe~=NULL) RunRoutines(location,describe);
          else
          {   if (location.description==0) RunTimeError(11,location);
              else PrintOrRun(location,description);
          }
      }
  } rfalse;
];

[ LookSub_O4 i j k;
  if (visibility_levels == 0) Locale(thedark);
  else
  {   for (i=player, j=visibility_levels: j>0: j--, i=parent(i))
          give i workflag;
      
      for (j=visibility_levels: j>0: j--)
      {   for (i=player, k=0: k<j: k++) i=parent(i);
          if (i.inside_description~=0)
          {   new_line; PrintOrRun(i,inside_description); }
          Locale(i);
      }
  }
  action=##Look; rfalse;
];

[ LookSub_O5; LookRoutine(); rfalse; ];
[ LookSub_O6; ScoreArrival(); rfalse; ];

[ ExamineSub_O1;
  if (noun.description == 0 && noun has container) {
      <<Search noun>>; rtrue; } rfalse;
];
[ ExamineSub_O2;
  if (noun.description == 0 && noun has switchable) {
      L__M(##Examine,3,noun); rtrue; } rfalse;
];
[ ExamineSub_O3;
  if (noun.description == 0) {
      return L__M(##Examine,2,noun); rtrue;
  } rfalse;
];
[ ExamineSub_O4;
  PrintOrRun(noun, description); rfalse;
];
[ ExamineSub_O5;
  if (noun has switchable) L__M(##Examine,3,noun); rfalse;
];

[ LookUnder_O1; return L__M(##LookUnder,2); ];

[ SearchSub_C1;
  if (~~(noun has container or supporter)) {
      L__M(##Search,4,noun); RulebookFails(); rtrue; } rfalse; ];
[ SearchSub_C2;
  if (noun has container && noun hasnt transparent && noun hasnt open) {
      L__M(##Search,5,noun); RulebookFails(); rtrue; } rfalse; ];
[ SearchSub_O1; rfalse; ];
[ SearchSub_R1 i f; if (noun has container) {
      objectloop (i in noun) if (i hasnt concealed && i hasnt scenery) f=1;
      if (f==0) return L__M(##Search,6,noun);
      return L__M(##Search,7,noun);
  } rfalse; ];
[ SearchSub_R2 i f; if (noun has supporter) {
      objectloop (i in noun) if (i hasnt concealed && i hasnt scenery) f=1;
      if (f==0) return L__M(##Search,2,noun);
      return L__M(##Search,3,noun);
  } rfalse; ];


! Actions which change the state of objects without moving them

[ LockSub_C1;
  if (noun hasnt lockable) { L__M(##Lock,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ LockSub_C2;
  if (noun has locked) { L__M(##Lock,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ LockSub_C3;
  if (noun has open) { L__M(##Lock,3,noun); RulebookFails(); rtrue; } rfalse; ];
[ LockSub_C4;
  if (noun.with_key~=second) { L__M(##Lock,4,noun); RulebookFails(); rtrue; } rfalse; ];
[ LockSub_O1; give noun locked; rfalse; ];
[ LockSub_R1; L__M(##Lock,5,noun); RulebookSucceeds(); rtrue; ];

[ UnlockSub_C1;
  if (noun hasnt lockable) { L__M(##Unlock,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ UnlockSub_C2;
  if (noun has locked) { L__M(##Unlock,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ UnlockSub_C3;
  if (noun.with_key~=second) { L__M(##Unlock,3,noun); RulebookFails(); rtrue; } rfalse; ];
[ UnlockSub_O1; give noun locked; rfalse; ];
[ UnlockSub_R1; L__M(##Unlock,4,noun); RulebookSucceeds(); rtrue; ];

[ SwitchOnSub_C1;
  if (noun hasnt switchable) { L__M(##SwitchOn,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ SwitchOnSub_C2;
  if (noun has on) { L__M(##SwitchOn,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ SwitchOnSub_O1; give noun on; rfalse; ];
[ SwitchOnSub_R1; L__M(##SwitchOn,3,noun); RulebookSucceeds(); rtrue; ];

[ SwitchOffSub_C1;
  if (noun hasnt switchable) { L__M(##SwitchOff,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ SwitchOffSub_C2;
  if (noun hasnt on) { L__M(##SwitchOff,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ SwitchOffSub_O1; give noun on; rfalse; ];
[ SwitchOffSub_R1; L__M(##SwitchOff,3,noun); RulebookSucceeds(); rtrue; ];

[ OpenSub_C1;
  if (noun hasnt openable) { L__M(##Open,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ OpenSub_C2;
  if (noun has locked) { L__M(##Open,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ OpenSub_C3;
  if (noun has open) { L__M(##Open,3,noun); RulebookFails(); rtrue; } rfalse; ];
[ OpenSub_O1; give noun open; rfalse; ];
[ OpenSub_R1;
  if (noun has container && noun hasnt transparent && child(noun)~=0
      && IndirectlyContains(noun,player)==0)
      return L__M(##Open,4,noun);
  rfalse; ];
[ OpenSub_R2; L__M(##Open,5,noun); RulebookSucceeds(); rfalse; ];

[ CloseSub_C1;
  if (noun hasnt openable) { L__M(##Close,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ CloseSub_C2;
  if (noun hasnt open) { L__M(##Close,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ CloseSub_O1; give noun ~open; rfalse; ];
[ CloseSub_R1; L__M(##Close,3,noun); RulebookSucceeds(); rtrue; ];

[ WearSub_C1;
  if (noun hasnt clothing) { L__M(##Wear,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ WearSub_C2;
  if (noun notin player) { L__M(##Wear,2,noun); RulebookFails(); rtrue; } rfalse; ];
[ WearSub_C3;
  if (noun has worn) { L__M(##Wear,3,noun); RulebookFails(); rtrue; } rfalse; ];
[ WearSub_O1; give noun worn; rfalse; ];
[ WearSub_R1; L__M(##Wear,4,noun); RulebookSucceeds(); rtrue; ];

[ DisrobeSub_C1;
  if (noun hasnt worn) { L__M(##Disrobe,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ DisrobeSub_O1; give noun ~worn; rfalse; ];
[ DisrobeSub_R1; L__M(##Disrobe,2,noun); RulebookSucceeds(); rtrue; ];

[ EatSub_C1;
  if (noun hasnt edible) { L__M(##Eat,1,noun); RulebookFails(); rtrue; } rfalse; ];
[ EatSub_C2;
  if (noun has worn) {
  	  L__M(##Drop,3,noun);
      <Disrobe noun>;
      if (noun has worn) { RulebookFails(); rtrue; } 
  }
  rfalse; ];
[ EatSub_O1; remove noun; rfalse; ];
[ EatSub_R1; L__M(##Eat,2,noun); RulebookSucceeds(); rtrue; ];

! Actions which are checked but then do nothing

[ TouchSub_R1;
  if (noun==player) return L__M(##Touch,3,noun); rfalse; ];
[ TouchSub_R2;
  if (noun has animate) return L__M(##Touch,1,noun); rfalse; ];
[ TouchSub_R3; return L__M(##Touch,2,noun); ];

[ WaveSub_C1;
  if (noun notin player) return L__M(##Wave,1,noun); rfalse; ];
[ WaveSub_R1; return L__M(##Wave,2,noun); ];

[ PullSub_C1;
  if (noun has static)   return L__M(##Pull,1,noun); rfalse; ];
[ PullSub_C2;
  if (noun has scenery)  return L__M(##Pull,2,noun); rfalse; ];
[ PullSub_C3;
  if (noun has animate)  return L__M(##Pull,4,noun); rfalse; ];
[ PullSub_R1; return L__M(##Pull,3,noun); ];

[ PushSub_C1;
  if (noun has static)   return L__M(##Push,1,noun); rfalse; ];
[ PushSub_C2;
  if (noun has scenery)  return L__M(##Push,2,noun); rfalse; ];
[ PushSub_C3;
  if (noun has animate)  return L__M(##Pull,4,noun); rfalse; ];
[ PushSub_R1; return L__M(##Push,3,noun); ];

[ TurnSub_C1;
  if (noun has static)   return L__M(##Turn,1,noun); rfalse; ];
[ TurnSub_C2;
  if (noun has scenery)  return L__M(##Turn,2,noun); rfalse; ];
[ TurnSub_C3;
  if (noun has animate)  return L__M(##Pull,4,noun); rfalse; ];
[ TurnSub_R1; return L__M(##Turn,3,noun); ];

[ PushDirSub_C1; return L__M(##PushDir,1,noun); ];

[ SqueezeSub_C1;
  if (noun has animate) return L__M(##Squeeze,1,noun); rfalse; ];
[ SqueezeSub_R1; return L__M(##Squeeze,2,noun); ];

! Actions concerning other people

[ GiveSub_C1;
  if (parent(noun)~=player) return L__M(##Give,1,noun); rfalse; ];
[ GiveSub_C2;
  if (second==player)  return L__M(##Give,2,noun); rfalse; ];
[ GiveSub_C3;
  if (RunLife(second,##Give)~=0) rtrue; rfalse; ];
[ GiveSub_C4; return L__M(##Give,3,second); ];

[ ShowSub_C1;
  if (parent(noun)~=player) return L__M(##Show,1,noun); rfalse; ];
[ ShowSub_C2;
  if (second==player) <<Examine noun>>; rfalse; ];
[ ShowSub_C3;
  if (RunLife(second,##Show)~=0) rtrue; rfalse; ];
[ ShowSub_C4; return L__M(##Show,2,second); ];

[ WakeOtherSub_C1;
  if (RunLife(noun,##WakeOther)~=0) rtrue; rfalse; ];
[ WakeOtherSub_C2; return L__M(##WakeOther,1,noun); ];

[ ThrowAtSub_C1;
  if (second>1) {
      action=##ThrownAt;
      if (RunRoutines(second,before)~=0) { action=##ThrowAt; rtrue; }
      action=##ThrowAt;
  } rfalse; ];
[ ThrowAtSub_C2;
  if (noun has worn) {
      L__M(##Drop,3,noun);
      <Disrobe noun>;
      if (noun has worn && noun in player) rtrue;
  } rfalse; ];
[ ThrowAtSub_C3;
  if (second hasnt animate) return L__M(##ThrowAt,1); rfalse; ];
[ ThrowAtSub_C4;
  if (RunLife(second,##ThrowAt)~=0) rtrue; rfalse; ];
[ ThrowAtSub_C5; return L__M(##ThrowAt,2,noun); ];

[ AttackSub_C1;
  if (noun has animate && RunLife(noun,##Attack)~=0) rtrue;
  rfalse; ];
[ AttackSub_C2; return L__M(##Attack,1,noun); ];

[ KissSub_C1; if (noun==player) return L__M(##Touch,3,noun); rfalse; ];
[ KissSub_C2;
  if (RunLife(noun,##Kiss)~=0) rtrue; rfalse; ];
[ KissSub_C3; return L__M(##Kiss,1,noun); ];

[ AnswerSub_C1;
  if (second~=0 && RunLife(second,##Answer)~=0) rtrue; rfalse; ];
[ AnswerSub_C2; return L__M(##Answer,1,noun); ];

[ TellSub_C1;
  if (noun==player) return L__M(##Tell,1,noun); rfalse; ];
[ TellSub_C2; if (RunLife(noun,##Tell)~=0) rtrue; rfalse; ];
[ TellSub_C3; return L__M(##Tell,2,noun); ];
  
[ AskSub_C1;
  if (RunLife(noun,##Ask)~=0) rtrue; rfalse; ];
[ AskSub_C2; return L__M(##Ask,1,noun); ];

[ AskForSub_C1; if (noun==player) <<Inv>>; rfalse; ];
[ AskForSub_C2; return L__M(##Order,1,noun); ];

! Actions blocked in all cases

[ YesSub_C1; return L__M(##Yes); ];
[ NoSub_C1; return L__M(##No); ];
[ BurnSub_C1; return L__M(##Burn); ];
[ PraySub_C1; return L__M(##Pray); ];
[ WakeSub_C1; return L__M(##Wake); ];
[ ThinkSub_C1; return L__M(##Think); ];
[ SmellSub_C1; return L__M(##Smell,1,noun); ];
[ ListenSub_C1; return L__M(##Listen,1,noun); ];
[ TasteSub_C1; return L__M(##Taste,1,noun); ];
[ DigSub_C1; return L__M(##Dig,1,noun); ];
[ CutSub_C1; return L__M(##Cut,1,noun); ];
[ JumpSub_C1; return L__M(##Jump,1,noun); ];
[ JumpOverSub_C1; return L__M(##JumpOver,1,noun); ];
[ TieSub_C1; return L__M(##Tie,1,noun); ];
[ DrinkSub_C1; return L__M(##Drink,1,noun); ];
[ FillSub_C1; return L__M(##Fill,1,noun); ];
[ SorrySub_C1; return L__M(##Sorry,1,noun); ];
[ StrongSub_C1; return L__M(##Strong,1,noun); ];
[ MildSub_C1; return L__M(##Mild,1,noun); ];
[ SwimSub_C1; return L__M(##Swim,1,noun); ];
[ SwingSub_C1; return L__M(##Swing,1,noun); ];
[ BlowSub_C1; return L__M(##Blow,1,noun); ];
[ RubSub_C1; return L__M(##Rub,1,noun); ];
[ SetSub_C1; return L__M(##Set,1,noun); ];
[ SetToSub_C1; return L__M(##SetTo,1,noun); ];
[ WaveHandsSub_C1; return L__M(##WaveHands,1,noun); ];
[ BuySub_C1; return L__M(##Buy,1,noun); ];
[ SingSub_C1; return L__M(##Sing,1,noun); ];
[ ClimbSub_C1; return L__M(##Climb,1,noun); ];
[ SleepSub_C1; return L__M(##Sleep,1,noun); ];
[ ConsultSub_C1; return L__M(##Consult,1,noun); ];
