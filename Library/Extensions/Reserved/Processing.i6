!! Processing.i6: code for processing rules and rulebooks

! The rule change stack contains 3-word (6 byte) records,
! defined thus in code generated by codegen.c:
! Constant RS_CAPACITY = 999;
! Global   rulechange_sp = 0;
! Array    rulechange_stack --> RS_CAPACITY;

[ PushRuleChange usage rule1 rule2;
  if (rulechange_sp >= RS_CAPACITY) {
      print "*** Rule change stack exhausted ***^^";
  }
  rulechange_stack-->rulechange_sp++ = usage;
  rulechange_stack-->rulechange_sp++ = rule1;
  rulechange_stack-->rulechange_sp++ = rule2;
];

! The first word of each record indicates a type, of which
! one value is special and indicates the start of a "follow"
! frame:

Constant RS_FRAME = -1;

! We also need to know the internal number of the procedural
! rulebook (which must correspond to that in the I7 source):

Constant APROC_RB = 0;
Constant AFTER_RB = 3;
Constant PROC_RB = 4;
Constant ACCESS_RB = 5;
Constant REACHIN_RB = 10;
Constant REACHOUT_RB = 11;
Constant TURNEND_RB = 9;
Constant GAME_BEGINS_RB = 22;
Constant GAME_ENDS_RB = 23;

! To "follow" a rulebook, we start a new frame, process the
! procedural rules, then process the rulebook, then clear
! the frame back off the stack:

Global rule_frames = 0;
[ BeginFollowRulebook;
  PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
  rule_frames++;
!print "+<", rule_frames, "/", rulechange_sp, ">";
  if (rule_frames == 20) {
      print ">--> Too many rulebooks are being followed at once. 
          Rulebooks pile up when the rules governing one
          action call for another action to take place first,
          and when the limit (20) is reached, this usually
          indicates that an action is directly or indirectly
          duplicating itself: for instance, 'Before going
          north, try going north.' has this effect.^^";
      rule_frames = -1;
      return;
  }
  ProcessRulebook(PROC_RB, 0, 1);
];
[ EndFollowRulebook;
  rule_frames--;
  while (rulechange_sp > 0) {
      rulechange_sp = rulechange_sp - 3;
      if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
  }      
  if (rulechange_sp == 0) rule_frames = 0;
!print "-<", rule_frames, "/", rulechange_sp, ">";
];
[ FollowRulebook rulebook par activity_flag rv;
!print "^{", rulebook, "}";
  if (rulebook ~= PROC_RB) BeginFollowRulebook();
  rv = ProcessRulebook(rulebook, par, activity_flag);
  if (rulebook ~= PROC_RB) EndFollowRulebook();
!print "{/", rulebook, "}";
  return rv;
];

! The rule changes pushed on to the stack have the following
! type numbers:

Constant RS_DONOTRUN   = 1;
Constant RS_RUN        = 2;
Constant RS_MOVEBEFORE = 3;
Constant RS_MOVEAFTER  = 4;
Constant RS_DONOTUSE   = 5;
Constant RS_USE        = 6;
Constant RS_SUBSTITUTE = 7;
Constant RS_SUCCEEDS   = 8;
Constant RS_FAILS      = 9;

! A variable logging the depth of recursion of rulebook
! processing, which at present is used only to print neatly
! formatted debugging:

Global process_rulebook_count;

! The main rulebook processing routine is
!   ProcessRulebook(rulebook/rule)
! which returns true if the rulebook or rule chose to
! "succeed" or "fail", and false if it made no choice.
! In the event that a choice was made, the result is left
! as a record above the top of the stack, and should be
! collected immediately.

! The following bitmap is used in a simple state machine:

Constant RS_ACTIVE_BIT = 1;
Constant RS_MOVED_BIT = 2;
Constant RS_USERESULT_BIT = 4;

Constant NO_DEBUGGABLES = 4;
Array debuggable_rulebooks --> APROC_RB PROC_RB ACCESS_RB TURNEND_RB;
Array debuggable_states --> 0 0 0 0;
[ DebugRbSub i;
  if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
      debuggable_states-->noun = 1;
      for (i=0:i<NO_DEBUGGABLES:i++) print debuggable_states-->i;
      " - OK";
  }
  "0 = actions, 1 = procedural, 2 = accessibility, 3 = turn sequence";
];
[ DebugRbOffSub i;
  if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
      debuggable_states-->noun = 0;
      for (i=0:i<NO_DEBUGGABLES:i++) print debuggable_states-->i;
      " - OK";
  }
  "0 = actions, 1 = procedural, 2 = accessibility, 3 = turn sequence";
];
Global debugging_rules = 0;
[ AdjustDbr s i;
  for (i=0:i<NO_DEBUGGABLES:i++) {
      if (s == debuggable_rulebooks-->i) {
          debugging_rules = debuggable_states-->i;
      }
  }
];
[ RulesOnSub;
  debug_rules = 1;
  "Rules tracing is now switched on. Type ~rules off~ to switch it off again,
   or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
  debug_rules = 2;
  "Rules tracing is now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
  debug_rules = 0;
  "Rules tracing is now switched off. Type ~rules~ to switch it on again.";
];
[ DB_Rule r f l;
  l = PhraseNames-->r;
  if (l==0) return;
  print "@31[Rule ~", (string) RuleTexts-->l, "~ ";
  if (f==0) "applies.]";
  "does not apply.]";
];

Verb meta "dbr"
	* number -> DebugRb
	* number "off" -> DebugRbOff;
Verb meta "rules"
	* -> RulesOn
	* "all" -> RulesAll
	* "off" -> RulesOff;

[ ProcessRulebook rulebook par activity_flag ignore_movements
  i rv bits x frame_base substituted_rule usage rule1 rule2 sdbr original_deadflag;
  if (rule_frames<0) rfalse;
  original_deadflag = deadflag;
  if (par) parameter_object = par;
  for (x = rulechange_sp-3: x>=0: x = x - 3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
      ! print x, ": US ", usage, " r1 ", rule1, " r2 ", rule2, "^";
      if (usage == RS_FRAME) { x=x+3; break; }
      if ((usage == RS_MOVEBEFORE) && (rule1 == rulebook))
          bits = bits | (RS_MOVED_BIT);
      if ((usage == RS_MOVEAFTER) && (rule1 == rulebook))
          bits = bits | (RS_MOVED_BIT);
  } if (x<0) x=0; frame_base = x;
  if ((bits & RS_MOVED_BIT) && (ignore_movements == false)) { rfalse; }
  bits = bits | RS_ACTIVE_BIT;
  bits = bits | RS_USERESULT_BIT;
  substituted_rule = rulebook;
!if (rulebook == GoSub_C10) { print "Want GSC10^x=", x, "^";
!for (i=0; i<rulechange_sp: i = i + 3) {
!      usage = rulechange_stack-->i;
!      rule1 = rulechange_stack-->(i+1);
!      rule2 = rulechange_stack-->(i+2);
!      print "Stack: ", usage, " ", rule1, " ", rule2, "^";
!}
!}
  for (: x<rulechange_sp: x = x + 3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
 !     if (rulebook == GoSub_C10) print "Found ", usage, " ", rule1, " ", rule2, "^";
      if ((usage == RS_DONOTRUN) && (rule1 == rulebook))
          bits = bits & (~RS_ACTIVE_BIT);
      if ((usage == RS_RUN) && (rule1 == rulebook))
          bits = bits | (RS_ACTIVE_BIT);
      if ((usage == RS_DONOTUSE) && (rule1 == rulebook))
          bits = bits & (~RS_USERESULT_BIT);
      if ((usage == RS_USE) && (rule1 == rulebook))
          bits = bits | (RS_USERESULT_BIT);
      if ((usage == RS_SUBSTITUTE) && (rule1 == rulebook))
          substituted_rule = rule2;
      if ((usage == RS_MOVEBEFORE) && (rule2 == rulebook)) {
           rv = ProcessRulebook(rule1, par, activity_flag, true);
           if (rv) { return rv; }
      }
  } ! if (rulebook == GoSub_C10) print "Bits: ", bits, "^";
  if ((bits & RS_ACTIVE_BIT) == 0) { rfalse; }
  sdbr = debugging_rules;
  AdjustDbr(substituted_rule);
  #ifndef I7_ECONOMY;
  if (debugging_rules) DebugRulebooks(substituted_rule, par);
  #endif;
  ! (A routine defined in the I7 code generator)
  process_rulebook_count = process_rulebook_count + debugging_rules;
  if ((substituted_rule >= 0) && (substituted_rule < HIGHEST_RULEBOOK_NO)) {
      substituted_rule = rulebooks_array-->substituted_rule;
      for (i=0, rv=0: (substituted_rule-->i~=$ffff) && (original_deadflag == deadflag): i++)
          if ((rv = (ProcessRulebook(substituted_rule-->i, par, activity_flag)))
              && (bits & RS_USERESULT_BIT)) break;
  } else {
      if ((say__p) && (activity_flag==false)) { new_line; say__p=0; }
      rv = indirect(substituted_rule);
      ! if ((say__p) && (activity_flag==false)) { new_line; say__p=0; }
  }
  if (rv && (bits & RS_USERESULT_BIT)) {
      AdjustDbr(substituted_rule);
  	  process_rulebook_count = process_rulebook_count - debugging_rules;
  	  if (process_rulebook_count < 0) process_rulebook_count = 0;
  	  if (debugging_rules) {
	      spaces(2*process_rulebook_count);
    	  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
    	      print "[stopped: success]^";
    	  if (rulechange_stack-->rulechange_sp == RS_FAILS)
    	      print "[stopped: fail]^";
      }
      debugging_rules = sdbr;
      return rv;
  }
  for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
      usage = rulechange_stack-->x;
      rule1 = rulechange_stack-->(x+1);
      rule2 = rulechange_stack-->(x+2);
      if ((usage == RS_MOVEAFTER) && (rule2 == rulebook)) {
          rv = ProcessRulebook(rule1, par, activity_flag, true);
          if (rv) { process_rulebook_count--;
              debugging_rules = sdbr;
      	      return rv;
      	  }
      }
  }
  process_rulebook_count = process_rulebook_count - debugging_rules;
  rulechange_stack-->rulechange_sp = 0;
  debugging_rules = sdbr;
  rfalse;
];

! The following routines provide a sort of rule-changing API:

[ ResultOfRule a;
  a = rulechange_stack-->rulechange_sp;
  if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
      a = rulechange_stack-->(rulechange_sp + 1);
      if (a) return rulechange_stack-->(rulechange_sp + 2);
  }
  rfalse;
];

[ RulebookSucceeds valueflag value;
  PushRuleChange(RS_SUCCEEDS, valueflag, value);
  rulechange_sp = rulechange_sp - 3;
];
[ RulebookFails valueflag value;
  PushRuleChange(RS_FAILS, valueflag, value);
  rulechange_sp = rulechange_sp - 3;
];

[ RulebookSucceeded;
  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue;
  rfalse;
];

[ SuppressRule rule;
  PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule;
  PushRuleChange(RS_RUN, rule, 0);
];
[ DonotuseRule rule;
  PushRuleChange(RS_DONOTUSE, rule, 0);
];
[ UseRule rule;
  PushRuleChange(RS_USE, rule, 0);
];
[ SubstituteRule rule1 rule2;
  PushRuleChange(RS_SUBSTITUTE, rule2, rule1);
];
[ MoveRuleBefore rule1 rule2;
  PushRuleChange(RS_MOVEBEFORE, rule1, rule2);
];
[ MoveRuleAfter rule1 rule2;
  PushRuleChange(RS_MOVEAFTER, rule1, rule2);
];

! Hooks to the I6 library:

[ BeginActionProcessing;
  BeginFollowRulebook();
];
[ EndActionProcessing;
  EndFollowRulebook();
];

! Replaced from the I6 library:

Global untouchable_object;
Global touch_persona;
[ ObjectIsUntouchable item flag1 flag2 p save_sp;
  untouchable_object = item;
  touch_persona = p;
  save_sp = say__p; say__p = 0;
  if (ProcessRulebook(ACCESS_RB, 0, 1)) {
      if (say__p) save_sp = true; else say__p = save_sp;
      if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
          rfalse; ! No barrier
      } else {
          rtrue; ! Barrier
      }
  }
  if (say__p) save_sp = true; else say__p = save_sp;
  ! No decision is interpreted as no barrier to access:
  rfalse;
];

[ OIU_Scoped i o;
!  i = ObjectScopedBySomething(untouchable_object);
!  if (i ~= 0) {
!      o = parameter_object;
!      if (ObjectIsUntouchable(i, 0, 0, touch_persona)) rtrue;
!      parameter_object = i;
!      return OIUB_CP();
!  }
  rfalse;
];

[ OIU_Core o;
  while (o && (o provides component_part_of) && (o.component_part_of))
      o = o.component_part_of;
  return o;
];

[ OIU_Parent o;
  return OIU_Core(parent(OIU_Core(o)));
];

[ OIU_CommonAncestor o1 o2 i j;
  !  Find the nearest object indirectly containing o1 and o2,
  !  or return 0 if there is no common ancestor.

  o1 = OIU_Core(o1);
  o2 = OIU_Core(o2);
  i = o1;
  while (i ~= 0) {
      j = o2;
      while (j ~= 0) {
          if (j == i) return i;
          j = OIU_Parent(j);
      }
	  i = OIU_Parent(i);
  }
  return 0;
];

[ OIU_Barrier ancestor i j external p;
  p = touch_persona; if (p == 0) p = player;

  ancestor = OIU_CommonAncestor(p, untouchable_object);
!  if (ancestor == 0) {
!      RulebookFails(); ! Wholly different locations
!      rtrue;
!  }
!  print "Doing OIU barriers for ", (the) p, " and ", (the) untouchable_object,
!      ": common ancestor is ", (the) ancestor, ".^";

  ! First, a barrier between the player and the ancestor.

  if (OIU_Core(p) ~= ancestor) {
      i = parent(OIU_Core(p)); j = OIU_Core(i); external = false;
      if (j ~= i) { i = j; external = true; }
      while (i~=ancestor && i) {
          if ((external == false) && (ProcessRulebook(REACHOUT_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
          i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
          if (j ~= i) { i = j; external = true; }
      }
  }

  ! Second, a barrier between the item and the ancestor.

  if (OIU_Core(untouchable_object) ~= ancestor) {
      i = parent(OIU_Core(untouchable_object)); j = OIU_Core(i); external = false;
      if (j ~= i) { i = j; external = true; }
      while (i~=ancestor && i) {
          if ((external == false) && (ProcessRulebook(REACHIN_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
          i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
          if (j ~= i) { i = j; external = true; }
      }
  }

  RulebookSucceeds(); ! No barrier
  rtrue;
];

[ OIUB_CCI;
  if (parameter_object has container && parameter_object hasnt open) {
      if (touch_persona == 0) L__M(##Take,9,parameter_object);
      RulebookFails();
      rtrue;
  }
  rfalse;
];

[ OIUB_CCO;
  if (parameter_object has container && parameter_object hasnt open) {
      if (touch_persona == 0) L__M(##Take,9,parameter_object);
      RulebookFails();
      rtrue;
  }
  rfalse;
];

[ OIUB_RI;
! print parameter_object, "=", (the) parameter_object, "^";
  if (parameter_object && parameter_object ofclass K1_room) {
      if (touch_persona == 0) L__M(##Take,14,parameter_object);
      RulebookFails();
      rtrue;
  }
  rfalse;
];

[ OIUB_CP;
  if ((noun provides component_part_of) && (noun.component_part_of)) {
	  if (noun.component_part_of has transparent)
	      return L__M(##Take,7,noun.component_part_of);
	  return L__M(##Take,8,noun.component_part_of);
  }
  rfalse;
];

[ TS1_R; AdvanceWorldClock(); rfalse; ];
[ TS2_R; RunTimersAndDaemons(); rfalse; ];
[ TS3_R; RunEachTurnProperties(); rfalse; ];
[ TS4_R; TimePasses(); rfalse; ];
[ TS5_R; AdjustLight(); rfalse; ];
[ TS6_R obj; NoteObjectAcquisitions();
  objectloop (obj in player)
      if (obj ofclass RUCKSACK_CLASS)
          SACK_OBJECT = obj;
  rfalse; ];

[ TestActionBitmap obj act i j k;
  if (obj == nothing) return ((ActionHappened->act) ~= 0);
  if (~~(obj provides action_bitmap)) rfalse;
  ! for (i=0; i<10; i++) print (obj.&action_bitmap)->i, " ";
  for (i=0, k=1; i<ActionCount; i++) {
      if (act == ActionCoding-->i) {
          return ((((obj.&action_bitmap)->j) & k) ~= 0);
      }
      k = k*2; if (k == 256) { k = 1; j++; }
  }
  rfalse;
];
[ SetActionBitmap obj act i j k;
  for (i=0, k=1; i<ActionCount; i++) {
      if (act == ActionCoding-->i) {
          if ((obj) && (obj provides action_bitmap)) {
      		  (obj.&action_bitmap)->0 =
                   ((obj.&action_bitmap)->0) | 1;
      		  (obj.&action_bitmap)->j =
                   ((obj.&action_bitmap)->j) | k;
              return;
          }
          ActionHappened->0 = (ActionHappened->0) | 1;
          ActionHappened->j = (ActionHappened->j) | k;
      }
      k = k*2; if (k == 256) { k = 1; j++; }
  }
];
Global debug_rule_nesting;
[ SetString31 d;
  switch(d) {
      0: string 31 "";
      1: string 31 "    ";
      2: string 31 "        ";
      3: string 31 "            ";
      4: string 31 "                ";
      default:
         string 31 "                    ";
  }
];
[ ActionPrimitive sa sn mf mt mb mth;
  sa = action; sn = noun; mf = move_from; mt = move_to;
  mb = move_by; mth = move_through;
  self = noun; say__p = 0;
  if (action == ##Consult or ##Ask or ##Tell or ##NotUnderstood or ##Answer) {
      inp2 = 1; second = consult_from + 256*consult_words;
  }
!  print noun, "/", second, ";", inp1, "/", inp2, "^";
  if (I7_VerifyNouns()) return;
!  print noun, "/", second, ";", inp1, "/", inp2, "^";
  if ((action == ##Go) && (noun)) {
      move_from = real_location; move_to = nothing;
      move_by = nothing; move_through = nothing;
      if ((parent(player) has container) && (parent(player) has enterable))
          move_by = parent(player);
      if ((parent(player) has supporter) && (parent(player) has enterable))
          move_by = parent(player);
      if (noun in compass) {
          move_to = move_from.(noun.door_dir);
      } else {
          if (noun has door) move_to = noun;
      }
      if ((move_to ~= nothing) && (move_to has door)) {
          move_through = move_to;
          move_to = move_to.door_to();
      }
      #IFDEF DEBUG;
      if ((debug_flag & 2 ~= 0)) {
          print "[Go with move_from = ";
          if (move_from) print (the) move_from; else print "nowhere";
          print ", move_to = ";
          if (move_to) print (the) move_to; else print "nowhere";
          print ", move_by = ";
          if (move_by) print (the) move_by; else print "nothing";
          print ", move_through = ";
          if (move_through) print (the) move_through; else print "nothing";
          print ", move_pushing = ";
          if (move_pushing) print (the) move_pushing; else print "nothing";
          print "]^";
      }
      #ENDIF;
  }

  #IFDEF DEBUG;
  if ((debug_rules) && (FindAction())) {
      print "@31["; DB_Action(); print "]^"; }
  SetString31(++debug_rule_nesting);
  #ENDIF;
  TrackActions();
  BeginActionProcessing();
  if (meta) { _I6_ActionPrimitive(); say__p = 1; }
  else ProcessRulebook(APROC_RB);
  #IFDEF DEBUG;
  if (debug_flag & 2 ~= 0) {
      switch (rulechange_stack-->rulechange_sp) {
          RS_SUCCEEDS: print "[Action succeeded]^";
          RS_FAILS: print "[Action failed]^";
          default: print "[Action ended without result]^";
      }
  }
  #ENDIF;
  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
      SetActionBitmap(noun, action);
      if (action == ##Go) SetActionBitmap(location, ##Enter);
  }
  SetString31(--debug_rule_nesting);
  EndActionProcessing();
  move_from = mf; move_to = mt; action = sa; noun = sn;
  move_by = mb; move_through = mth;
];
[ GenericVerbSub ch co re;
  if (ProcessRulebook(ch)) { RulebookFails(); rtrue; }
  if (ProcessRulebook(co)) jump HappyEnding;
  if (keep_silent) jump HappyEnding;
  if (ProcessRulebook(AFTER_RB)) jump HappyEnding;
  ProcessRulebook(re);
  .HappyEnding; RulebookSucceeds(); rtrue;
];
[ AllowPushDir i;
  if ((noun provides i7_kind) && (noun hasnt pushable))
      return L__M(##PushDir,1,noun);
  if (parent(second)~=compass) return L__M(##PushDir,2,noun);
  if (second==u_obj or d_obj)  return L__M(##PushDir,3,noun);
  AfterRoutines(); i=noun; move i to player; move_pushing = i;
  <Go second>;
  move_pushing = nothing;
  if (location==thedark) move i to real_location;
  else move i to location;
];
[ SetI7Timer R t f i b;
  for (i=1: i<=(I7TimerTable-->0): i++) {
      if (R == I7TimerTable-->i) { b=i; jump SlotFound; }
      if ((b==0) && (I7TimerTable-->i == 0)) b=i;
  }
  if (b==0) ">--> Too many timed events are going on at once.";
  .SlotFound;
  I7TimerTable-->b = R;
  if (f == 0) I7TimerTableTimes-->b = -t;
  else I7TimerTableTimes-->b = t;
];
[ ProcessI7Timers i t f r;
  for (i=1: i<=(I7TimerTable-->0): i++)
      if ((r=I7TimerTable-->i) ~= 0) {
          t = I7TimerTableTimes-->i; f = 0;
          if (t<0) {
              (I7TimerTableTimes-->i)++;
              if (I7TimerTableTimes-->i == 0) f=1;
          } else {
              if ((the_time >= t) && (the_time < t+30)) f=1;
          }
          if (f) {
              I7TimerTable-->i = 0;
              ProcessRulebook(r);
          }
      }
  rfalse;
];
[ SetDaemonRule d s i j;
  j = daemonic_rules-->0;
  for (i=1: i<=j: i++) {
      if (daemonic_rules-->i == d) {
          daemon_activity->(i-1) = s;
          return;
      }
  }
  ">--> You tried to start or stop a rule which was not a daemon.";
];

[ DA_Name n; print (name) n; ];
[ DA_Topic ignore a b c d i;
  print "~";
  for (a=consult_from:d<consult_words:d++,a++) {
      wn = a; b = WordAddress(a); c = WordLength(a);
      for (i=b:i<b+c:i++) {
          print (char) 0->i;
      }
      if (d<consult_words-1) print " ";
  }
  print "~";
];
[ DA_Number n; print n; ];
[ FindAction t;
  t = 1;
  while (t <= ActionData-->0) {
      if (action == ActionData-->t) return t;
      t = t+9;
  }
  rfalse;
];
[ DB_Action t l j v c;
  t = 1;
  while (t <= ActionData-->0) {
      if (action == ActionData-->t) {
          l = t+9; t = t+4;
          while ((v = ActionData-->t) ~= $ffff) {
              if (v ofclass Routine) {
                  if (c==0) { (v)(noun); }
                  else { (v)(second); }
                  c++;
              } else print (string) v;
              t++;
              if (t == l) break;
              if (ActionData-->t ~= $ffff) print " ";
          }
          if (keep_silent) print " - silently";
          return;
      }
      t = t+9;
  }
];

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];
[ PrintTimeOfDay t h aop;
  if (t<0) { print "<no time>"; return; }
  if (t >= 60*12) { aop = "pm"; t=t-60*12; } else aop = "am";
  h = t/60; if (h==0) h=12;
  print h, ":";
  if (t%60<10) print "0"; print t%60, " ", (string) aop;
];
[ PrintTimeOfDayEnglish t h m dir aop;
  h = (t/60) % 12; m = t%60; if (h==0) h=12;
  if (m==0) { print (number) h, " o'clock"; return; }
  dir = "past";
  if (m > 30) { m = 60-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
  switch(m) {
  	15: print "quarter"; 30: print "half";
  	default: print (number) m;
  	    if (m%5 ~= 0) {
  	        if (m == 1) print " minute"; else print " minutes";
  	    }
  }
  print " ", (string) dir, " ", (number) h;
];
[ PermitAttributeR obj off i;
  ! print "Asking permission of ", (the) obj, "^";
  i=off; while (property_metadata-->i >= 0) {
  if (obj == property_metadata-->i) rtrue; i++; }
  rfalse; ];
[ PermitAttribute f obj att off textual i a l; if (att<0) att = ~att;
  if (metaclass(obj) ~= Object) rfalse;
  if (f) off = attribute_offsets-->att; else off = property_offsets-->att;
  if (off<0) {
  print ">--> Bad property on ", (the) obj, "^"; rtrue; }
  textual = property_metadata-->off; off++;
  if (PermitAttributeR(obj, off)) jump Okay;
  if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
  for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
  print ">--> Since ", (the) obj, " is not allowed the property ~",
      (string) textual, "~, it is against the rules to try to use it.^";
  rfalse;
  .Okay; if (f) rtrue;
  if (obj provides att) rtrue;
  print ">--> Although ", (the) obj, " is allowed to have the property ~",
      (string) textual, "~, no value was ever given, so it can't now be used.^";
  rfalse; ];
[ AccessProp obj pr;
  if (PermitAttribute(false, obj, pr)) return obj.pr;
  rfalse; ];
[ WriteAccessProp obj pr val;
  if (PermitAttribute(false, obj, pr)) obj.pr = val; ];
[ I7_Para x; say__p = 1; ];
[ I7_LineBreak; if (say__p) { new_line; say__p=0; } ];
[ I7_ParaBreak; if (say__p) { new_line; new_line; say__p=0; } ];
[ I7_Prompt i;
  ! print "^";
  style roman;
  I7_LineBreak();
  switch(metaclass(I7_prompt_text)) {
      String: print (string) I7_prompt_text;
      Routine: I7_prompt_text();
  }
  if (I7_box) {
      for (i=0: I7_boxes_appeared-->i: i++)
          if (I7_boxes_appeared-->i == I7_box) {
              I7_box = 0;
              return;
          }
      I7_boxes_appeared-->i = I7_box;
      I7_box();
      I7_box = 0;
  }
];
[ SL_Score_Moves;
  print sline1, "/", sline2;
];
[ SL_Location;
   if (location == thedark) print (name) location;
   else
   {   FindVisibilityLevels();
       if (visibility_ceiling == location)
           print (name) location;
       else print (The) visibility_ceiling;
   }
];
[ DrawStatusLine width posb;
   BeginActivity(3);
   @split_window 1; @set_window 1; @set_cursor 1 1; style reverse;
   width = 0->33; posb = width-15;
   spaces width;
   if (ForActivity(3) == false) {
   @set_cursor 1 2;
   switch(metaclass(I7_left_sl)) {
       String: print (string) I7_left_sl;
       Routine: I7_left_sl();
   }
   @set_cursor 1 posb;
   switch(metaclass(I7_right_sl)) {
       String: print (string) I7_right_sl;
       Routine: I7_right_sl();
   }
   }
   @set_cursor 1 1; style roman; @set_window 0;
   EndActivity(3);
];
[ I7_parent o; if (o==0) return 0; return parent(o); ];

Global activities_sp = 0;
Array activities_stack --> 25;
Array activities_ostack --> 25;
Global inhibit_flag = 0;
Global inhibit_dr = 0;
[ FixInhibitFlag n i_f;
  for (n=0:n<activities_sp:n++)
      if (activities_stack-->n <= 4) i_f = true;
  if ((inhibit_flag == false) && (i_f)) {
      inhibit_dr = debug_rules;
      debug_rules = 0;
  }
  if ((inhibit_flag) && (i_f == false)) {
      debug_rules = inhibit_dr;
  }
  inhibit_flag = i_f;
];
[ FollowRulebookSelfed R o ss rv;
  ss = self; if (o) self = o;
  rv = FollowRulebook(R, o, true);
  self = ss; return rv;
];
[ BeginActivity A o;
  if (activities_sp == 25) ">--> Too many activities going on at once.";
  activities_ostack-->activities_sp = o;
  activities_stack-->(activities_sp++) = A;
  FixInhibitFlag();
  return FollowRulebookSelfed(Activity_before_rulebooks-->A, o);
];
[ ForActivity A o;
  return FollowRulebookSelfed(Activity_when_rulebooks-->A, o);
];
[ EndActivity A o rv;
  if (activities_sp == 0) jump BadEnd;
  if (activities_stack-->(activities_sp-1) == A) {
      rv = FollowRulebookSelfed(Activity_after_rulebooks-->A, o);
      activities_sp--; FixInhibitFlag(); return rv; }
  .BadEnd; ">--> Tried to abandon activity which wasn't going on.";
];
[ AbandonActivity A o;
  if (activities_sp == 0) jump BadEnd;
  if (activities_stack-->(activities_sp-1) == A) {
      activities_sp--; FixInhibitFlag(); return; }
  .BadEnd; ">--> Tried to end activity which wasn't going on.";
];
[ CarryOutActivity A o;
  BeginActivity(A,o); ForActivity(A,o); EndActivity(A,o); ];
[ TestActivity A Pattern i;
  for (i=0:i<activities_sp:i++)
      if (activities_stack-->i == A) {
          if (Pattern == false) rtrue;
          if ((Pattern)(activities_ostack-->i)) rtrue;
      }
  rfalse;
];
[ I7_Move F T opt;
  if (F == false) ">--> You can't move nothing.";
  give F ~worn;
  if (F == player) PlayerTo(T, opt); else move F to T;
];
[ I7_Wear F T opt;
  if (F == false) rfalse;
  I7_Move(F, T, opt);
  give F worn;
];
[ I7_MakePart P Of;
  print "Sorry, don't know how to make ", (the) P, " part of ", (the) Of, ".^";
];
[ I7_NPCA;
  if (actor == player) rfalse;
  L__M(##Order, 1, actor);
  RulebookFails(); rtrue;
];
[ I7_PlaceInScope O opts;
  if (opts) return PlaceInScope(O);
  if (O ofclass K2_thing) PlaceInScope(O);
  ScopeWithin(O);
];
[ I7_Match test snippet w1 wlen i j;
  w1 = snippet/100; wlen = snippet%100;
  for (i=w1, j=wlen: j>0: i++, j--) {
      if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
  }
  rfalse;
];
[ I7_ParseToken x y; if (wn>parse->1) return GPR_FAIL;
  return ParseToken(x,y); ];
[ I7_say_s; if (say__n ~= 1) print "s"; ];
[ I7_Amusing_Provided x;
  x = Activity_when_rulebooks-->AMUSING_ACT;
  if (((rulebooks_array-->x)-->0) == $ffff)
      rfalse;
  rtrue;
];
[ I7_CarriedBy obj p; p = parent(obj);
  if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
  return nothing;
];
[ I7_WornBy obj p; p = parent(obj);
  if (p && (p ofclass K8_person) && (obj has worn)) return p;
  return nothing;
];
[ I7_HadBy obj p; p = parent(obj);
  if (p && (p ofclass K8_person)) return p;
  return nothing;
];
[ I7_Adjacent R1 R2 d pr;
  objectloop (d in compass) {
      pr = d.door_dir;
      if ((R1 provides pr) && (R2 == R1.pr)) rtrue;
  }
  rfalse;
];
[ I7_string s; if (s ofclass String) { print (string) s; return; }
  indirect(s);
];
[ I7_In rm region o;
  if ((rm == nothing) || (region == nothing)) rfalse;
  o = rm.I7_Map_Region;
  if (o == region) rtrue;
  if (o) return I7_In(o, region);
  rfalse;
];
[ I7SwapWF obj lst;
  objectloop (obj ofclass Object) {
      lst = false;
      if (obj has i7listflag) lst = true;
      give obj ~i7listflag;
      if (obj has workflag) give obj i7listflag;
      give obj ~workflag;
      if (lst) give obj workflag;
  }
];
[ I7List supp obj par flag mixed ct defart;
  objectloop (obj ofclass Object && obj has i7listflag) {
      ct++;
      if (flag == false) {
          flag = true; par = parent(obj);
      } else {
          if (parent(obj) ~= par) mixed = true;
      }
  }
  if (ct == 0) { print "nothing"; return; }
  if (supp < 0) { supp = -supp; mixed = true; defart = true; }
  if (supp & ISARE_BIT) {
      if (ct > 1) print "are "; else print "is ";
      supp = supp - ISARE_BIT;
  }
  if ((mixed == false) && (par)) {
      ct = c_style;
      I7SwapWF();
      ! print "<";
      WriteListFrom(child(par), ENGLISH_BIT+WORKFLAG_BIT+supp);
      I7SwapWF();
      ! print ">";
      c_style = ct;
      return;
  }
  objectloop (obj ofclass Object && obj has i7listflag) {
      give obj ~i7listflag;
      if (supp & DEFART_BIT) {
          if (defart) print (The) obj; else print (the) obj;
          defart = false;
      } else print (a) obj;
      ct--;
#ifdef US_DIALECT;
      if (ct == 1) print ", and ";
#ifnot;
      if (ct == 1) print " and ";
#endif;
      if (ct > 1) print ", ";
 }
! print ">";
];
[ I7_CanSee A B;
  if (location == thedark) rfalse;
  return TestScope(B, A);
];
[ I7_CanTouch A B;
  if (TestScope(B,A) == false) rfalse;
  if (ObjectIsUntouchable(B, 0, 0, A)) rfalse;
  rtrue;
];
