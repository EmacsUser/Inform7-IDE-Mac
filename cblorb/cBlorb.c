/* ---------------------------------------------------------------------------   cBlorb: a perl script for creating Blorb files    (c) Graham Nelson 1998, 2005    --------------------------------------------------------------------------- */#define TEMP_PREFIX "Temp" /* Prefix for location of temporary directory */#define file_sep '/'#define VERSION "cBlorb 1.03"char *blurb_filename = "blurb.txt";char *output_filename = "story.zlb";#include "stdlib.h"#include "stdio.h"#include "time.h"time_t the_present;struct tm *here_and_now;char blorbdate[128];char temp_dir[1024];char stupidly_big[102400];char *filename_space;#define MAX_CHUNKS 500char *chunk_filename_array[MAX_CHUNKS];int chunk_important_array[MAX_CHUNKS];char *chunk_id_array[MAX_CHUNKS];int chunk_size_array[MAX_CHUNKS];int chunk_number_array[MAX_CHUNKS];int chunk_offset_array[MAX_CHUNKS];int picture_numbering[MAX_CHUNKS];int sound_numbering[MAX_CHUNKS];int blurb_line = 0;int chunk_opened = 0;int chunk_count = 0;int important_count = 0;int total_size = 0;int past_idx_offset = 0;int max_resource_num = 0;int scalables = 0;int repeaters = 0;int next_pnum = 1;int next_snum = 3;int r_stdx = 600, r_stdy = 400;int r_minx = 0, r_maxx = 0;int r_miny = 0, r_maxy = 0;int resolution_on = 0;int iff_size = 0, pcount = 0, scount = 0;int error_count = 0;FILE *CHUNK = NULL;/* ---------- *//*void ensure_tempdir(void){   if (opendir(TDIR, temp_dir))    {   closedir(TDIR);    }    else    {   if (mkdir(temp_dir, 0) == 0)        { die("Fatal error: unable to create working directory temp_dir");        }    }}void remove_tempdir(void){   if (opendir(TDIR, temp_dir))    {   @allfiles = grep !/^\./, readdir TDIR;        closedir(TDIR);        foreach $file (@allfiles)        {   $fullfile = sprintf("%s%s%s", temp_dir, $file_sep, $file);            unlink $fullfile;        }        rmdir(temp_dir);    }}*//* ---------- */void error(char *erm) {    fprintf(stderr, "%s, line %d: Error: %s\n", blurb_filename, blurb_line, erm);    error_count++;}void fatal(char *erm) {    fprintf(stderr, "%s, line %d: Fatal error: %s\n", blurb_filename, blurb_line, erm);    exit(1);}/* ---------- */void four_word(int n) {    fprintf(CHUNK, "%c%c%c%c", (n / 0x1000000),                               (n / 0x10000)%0x100,                               (n / 0x100)%0x100,                               (n)%0x100);}void two_word(int n) {    fprintf(CHUNK, "%c%c", (n / 0x100), (n)%0x100);}void one_byte(int n) {    fprintf(CHUNK, "%c", n);}void begin_chunk(char *id, int cnum, char *chunk_filename) {	int chunk_opened = 0;    if (cnum > max_resource_num) { max_resource_num = cnum; }    if (chunk_filename == NULL) {    	sprintf(filename_space, "%s%cC%d.chunk", temp_dir, file_sep, chunk_count);    	chunk_filename = filename_space;    	filename_space += strlen(filename_space)+1;           		CHUNK = fopen(chunk_filename, "wb");        if (CHUNK == NULL) fatal("unable to create temporary file chunk_filename");    	chunk_opened = 1;    } else {    	sprintf(filename_space, "%s", chunk_filename);    	chunk_filename = filename_space;    	filename_space += strlen(filename_space)+1;    }	if (chunk_count >= MAX_CHUNKS) fatal("exceeded maximum number of chunks");    chunk_filename_array[chunk_count] = chunk_filename;    chunk_important_array[chunk_count] = 0;    if ((strcmp(id, "Pict")==0) || (strcmp(id, "Snd1")==0) || (strcmp(id, "Snd2")==0)        || (strcmp(id, "Snd3")==0) || (strcmp(id, "Exec")==0)) {    	chunk_important_array[chunk_count] = 1;        important_count = important_count + 1;            }    chunk_id_array[chunk_count] = id;    chunk_number_array[chunk_count] = cnum;    chunk_offset_array[chunk_count] = total_size;}void end_chunk(void) {	int size, blen, buffer; char *chunk_filename;    if (chunk_opened == 1) close(CHUNK);    chunk_opened = 0;    chunk_filename = chunk_filename_array[chunk_count];printf("Ended chunk: fn is <%s>\n", chunk_filename);    CHUNK = fopen(chunk_filename_array[chunk_count], "rb");    if (CHUNK == NULL) fatal("unable to open chunk for size counting");    for (size = 0; feof(CHUNK) == 0; size++) fgetc(CHUNK);    close(CHUNK);    if (strcmp(chunk_id_array[chunk_count], "Snd1") != 0) size += 8;    chunk_size_array[chunk_count] = size;    if (size % 2 == 1) size++;    total_size += size;    chunk_count++;}void author_chunk(char *t) {    begin_chunk("AUTH", 0, NULL);    fprintf(CHUNK, "%s", t);    end_chunk();}void copyright_chunk(char *t) {    begin_chunk("(c) ", 0, NULL);    fprintf(CHUNK, "%s", t);    end_chunk();}void release_chunk(int rn) {    begin_chunk("RelN", 0, NULL);    two_word(rn);    end_chunk();}void palette_simple_chunk(int p) {    begin_chunk("Plte", 0, NULL);    one_byte(p);    end_chunk();}void picture_chunk(int n, char *fn) {    begin_chunk("Pict", n, fn);    end_chunk();}void sound1_chunk(int n, char *fn) {    begin_chunk("Snd1", n, fn);    end_chunk();}void sound2_chunk(int n, char *fn) {    begin_chunk("Snd2", n, fn);    end_chunk();}void sound3_chunk(int n, char *fn) {    begin_chunk("Snd3", n, fn);    end_chunk();}void executable_chunk(char *fn) {    begin_chunk("Exec", 0, fn);    end_chunk();}void metadata_chunk(char *fn) {    begin_chunk("IFmd", 0, fn);    end_chunk();}/* ---------- */void identify(char *symb, int val) {    printf("Constant %s = %d;\n", symb, val);}void interpret(char *command) {	char keyword[128];	char sv[128]; int iv;		blurb_line++;		sscanf(command, "%s", keyword);		if (keyword[0] == 0) return; /* Blank line */    if (keyword[0] == '!') return; /* Comment line */printf("Line %d: command <%s> keyword <%s>\n", blurb_line, command, keyword);		if (sscanf(command, "copyright \"%s\"", sv) == 1) {		copyright_chunk(sv);        return;    }	if (sscanf(command, "release %d", &iv) == 1) {		release_chunk(iv);        return;    }/*    if ($command =~ /^\s*resolution\s+(\d*)x(\d*)\s*(.*)$/m)    {   $r_stdx = $1; $r_stdy = $2;        $r_minx = 0; $r_maxx = 0;        $r_miny = 0; $r_maxy = 0;        $resolution_on = 1;        $rest = $3;        if ($rest =~ /^\s*min\s+(\d*)x(\d*)\s*$/m)        {   $r_minx = $1;            $r_miny = $2;            return;        }        if ($rest =~ /^\s*max\s+(\d*)x(\d*)\s*$/m)        {   $r_maxx = $1;            $r_maxy = $2;            return;        }        if ($rest =~ /^\s*min\s+(\d*)x(\d*)\s*max\s+(\d*)x(\d*)\s*$/m)        {   $r_minx = $1;            $r_miny = $2;            $r_maxx = $3;            $r_maxy = $4;            return;        }        if ($rest =~ /^\s*$/m)        {   return;        }    }    if ($command =~ /^\s*palette\s+(\d*)\s*bit/)    {   if (($1 == 16) || ($1 == 32))        {   palette_simple_chunk($1);            return;        }        error("palette can only be 16 or 32 bit");        return;    }    if ($command =~ /^\s*palette\s*\{(.*)$/m)    {   $rest = $1;        begin_chunk("Plte", 0, "");        while (not($rest =~ /^\s*\}/))        {   if ($rest =~ /^\s*$/m)            {   $rest = <BLURB> or fatal("end of blurb file in 'palette'");                $blurb_line = $blurb_line + 1;            }            else            {   if ($rest =~            /^\s*([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})\s*(.*)$/m)                {   $rest = $4;                    one_byte(hex($1));                    one_byte(hex($2));                    one_byte(hex($3));                }                else                {   $rest =~ /^\s*(\S+)\s*(.*)$/m;                    error("palette entry not six hex digits: $1");                    $rest = $2;                }            }        }        end_chunk();        return;    } */        if (sscanf(command, "metadata \"%[^\"]\" include", sv) == 1) {    	metadata_chunk(sv); return;    }    if (sscanf(command, "storyfile \"%[^\"]\" include", sv) == 1) {    	executable_chunk(sv); return;    }    if (sscanf(command, "storyfile \"[^\"]\"", sv) == 1) {    	error("can only include story files in this minimal cBlorb"); return;    }/*    if ($command =~ /^\s*storyfile\s+"(.*)"/)    {   open(IDFILE, $1) or fatal("unable to open story file $1");        binmode(IDFILE);        begin_chunk("IFhd", 0, "");        $version = unpack("C", getc(IDFILE));        printf("! Identifying v$version story file $1\n";        read IDFILE, $buffer, 1;        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        read IDFILE, $buffer, 14;        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        read IDFILE, $buffer, 4;        one_byte(unpack("C",getc(IDFILE)));        one_byte(unpack("C",getc(IDFILE)));        one_byte(0);        one_byte(0);        one_byte(0);        end_chunk();        close(IDFILE);        return;    } *//*    if ($command =~ /^\s*picture\s+([a-zA-Z_0-9]*)\s*"(.*)"\s*(.*)$/m)    {   $pnumt = $1; $pfile = $2; $rest = $3;        if ($pnumt =~ /^\d+$/m)        {   $pnum = $pnumt;            if ($pnum < $next_pnum)            {   error("picture number must be >= $next_pnum to avoid clash");            }            else            {   $next_pnum = $pnum + 1;            }        }        else        {   $pnum = $next_pnum;            $next_pnum = $next_pnum + 1;            if ($pnumt ne "")            {   identify("PICTURE_$pnumt", $pnum);            }        }        picture_chunk($pnum, $pfile);        if ($rest =~ /^\s*$/m)        {   return;        }        $scalables = $scalables + 1;        $resolution_on = 1;        $p_picno[$scalables] = $pnum;        $p_stdp[$scalables] = 1; $p_stdq[$scalables] = 1;        $p_minp[$scalables] = -1; $p_maxp[$scalables] = -1;        $p_minq[$scalables] = -1; $p_maxq[$scalables] = -1;        if ($rest =~ /^\s*scale\s+(\d*)\/(\d*)\s*$/m)        {   $p_stdp[$scalables] = $1;            $p_stdq[$scalables] = $2;            return;        }        if ($rest =~ /^\s*scale\s+max\s*(\d*)\/(\d*)\s*$/m)        {   $p_maxp[$scalables] = $1;            $p_maxq[$scalables] = $2;            return;        }        if ($rest =~ /^\s*scale\s+min\s*(\d*)\/(\d*)\s*$/m)        {   $p_minp[$scalables] = $1;            $p_minq[$scalables] = $2;            return;        }        if ($rest =~            /^\s*scale\s+min\s*(\d*)\/(\d*)\s+max\s*(\d*)\/(\d*)\s*$/m)        {   $p_minp[$scalables] = $1;            $p_minq[$scalables] = $2;            $p_maxp[$scalables] = $3;            $p_maxq[$scalables] = $4;            return;        }        if ($rest =~ /^\s*scale\s*(\d*)\/(\d*)\s*max\s*(\d*)\/(\d*)\s*$/m)        {   $p_stdp[$scalables] = $1;            $p_stdq[$scalables] = $2;            $p_maxp[$scalables] = $3;            $p_maxq[$scalables] = $4;            return;        }        if ($rest =~ /^\s*scale\s*(\d*)\/(\d*)\s*min\s*(\d*)\/(\d*)\s*$/m)        {   $p_stdp[$scalables] = $1;            $p_stdq[$scalables] = $2;            $p_minp[$scalables] = $3;            $p_minq[$scalables] = $4;            return;        }        if ($rest =~  /^\s*scale\s*(\d*)\/(\d*)\s*min\s*(\d*)\/(\d*)\s+max\s*(\d*)\/(\d*)\s*$/m)        {   $p_stdp[$scalables] = $1;            $p_stdq[$scalables] = $2;            $p_minp[$scalables] = $3;            $p_minq[$scalables] = $4;            $p_maxp[$scalables] = $5;            $p_maxq[$scalables] = $6;            return;        }    }    if ($command =~ /^\s*sound\s+([a-zA-Z_0-9]*)\s*"(.*)"\s*(.*)$/m)    {   $snumt = $1;        $fxfile = $2;        $repeats = $3;        if ($snumt =~ /^\d+$/m)        {   $snum = $snumt;            if ($snum < $next_snum)            {   error("sound number must be >= $next_snum to avoid clash");            }            else            {   $next_snum = $snum + 1;            }        }        else        {   $snum = $next_snum;            $next_snum = $next_snum + 1;            if ($snumt ne "")            {   identify("SOUND_$snumt", $snum);            }        }        if ($repeats eq "music")        {   sound2_chunk($snum, $fxfile);            return;        }        if ($repeats eq "song")        {   sound3_chunk($snum, $fxfile);            return;        }        sound1_chunk($snum, $fxfile);        if ($repeats =~ /^repeat\s+forever\s*$/m)        {   $looped_fx[$repeaters] = $snum;            $looped_num[$repeaters] = 0;            $repeaters = $repeaters + 1;            return;        }        if ($repeats =~ /^repeat\s+(\d*)\s*$/m)        {   $looped_fx[$repeaters] = $snum;            $looped_num[$repeaters] = $1;            $repeaters = $repeaters + 1;            return;        }        if ($repeats eq "") { return; }    }*/    if (((strcmp(keyword, "palette"))==0)    	|| ((strcmp(keyword, "picture"))==0)        || ((strcmp(keyword, "resolution"))==0)        || ((strcmp(keyword, "sound"))==0)) {    	error("command not yet implemented in this minimal cBlorb");        return;    }    if (((strcmp(keyword, "copyright"))==0)    	|| ((strcmp(keyword, "palette"))==0)    	|| ((strcmp(keyword, "picture"))==0)        || ((strcmp(keyword, "release"))==0)        || ((strcmp(keyword, "resolution"))==0)        || ((strcmp(keyword, "sound"))==0)        || ((strcmp(keyword, "storyfile"))==0)) {    	error("incorrect syntax for this command");        return;    }    error("no such blurb command"); printf("Keyword: %s\n", keyword);}/* ---------- */int main(int argc, char *argv[]) {	char auth_chunk[128], line[1024]; char *type; FILE *BLURB, *CHUNKSUB;	int i, x; char c; char *chunk_filename;	if ((argc <= 1) || (argc > 3)) {		fprintf(stderr, "usage: cblorb blurbfile [blorbfile]");		exit(1);	}	blurb_filename = argv[1];	if (argc == 3) output_filename = argv[2];	filename_space = (char *) (stupidly_big);	the_present = time(NULL);	here_and_now = localtime(&the_present);	sprintf(blorbdate, "%02d%02d%02d at %02d:%02d.%02d",		here_and_now->tm_year-100, here_and_now->tm_mon + 1,		here_and_now->tm_mday, here_and_now->tm_hour,		here_and_now->tm_min, here_and_now->tm_sec);	sprintf(temp_dir, "%s", TEMP_PREFIX);		printf("! %s [executing on %s]\n", VERSION, blorbdate);	printf("! The blorb spell (safely protect a small object ");	printf("as though in a strong box).\n");		sprintf(auth_chunk, "%s on %s", VERSION, blorbdate);	author_chunk(auth_chunk);	BLURB = fopen(blurb_filename, "r");	if (BLURB == NULL) fatal("can't open blurb file");	i=0; c = ' ';	while (c != EOF) {		c = fgetc(BLURB);		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {			line[i] = 0; interpret(line); i=0;		} else line[i++] = c;	}	if (i>0) { line[i] = 0; interpret(line); }	fclose(BLURB);	/* if ($resolution_on == 1)	{   		begin_chunk("Reso", 0, "");		four_word($r_stdx);		four_word($r_stdy);		four_word($r_minx);		four_word($r_miny);		four_word($r_maxx);		four_word($r_maxy);			for ($x=1; $x<=$scalables; $x=$x+1)		{   four_word($p_picno[$x]);			four_word($p_stdp[$x]);			four_word($p_stdq[$x]);				if ($p_minp[$x] == -1)			{   $p_minp[$x] = $p_stdp[$x]; $p_minq[$x] = $p_stdq[$x]; }				if ($p_maxp[$x] == -1)			{   $p_maxp[$x] = $p_stdp[$x]; $p_maxq[$x] = $p_stdq[$x]; }				four_word($p_minp[$x]);			four_word($p_minq[$x]);			four_word($p_maxp[$x]);			four_word($p_maxq[$x]);    		}		end_chunk();	}		if ($repeaters > 0)	{   begin_chunk("Loop", 0, "");		for ($x=0; $x<$repeaters; $x = $x + 1)		{   four_word($looped_fx[$x]);			four_word($looped_num[$x]);        		}		end_chunk();	} */	/* Calculate the IFF file size */		past_idx_offset = 12 + 12 + 12*important_count;	iff_size = past_idx_offset + total_size;		/* Now construct the IFF file from the chunks */	CHUNK = fopen(output_filename, "wb");	if (CHUNK == NULL) fatal("can't open blorb file for output");	fprintf(CHUNK, "FORM");	four_word(iff_size - 8);	fprintf(CHUNK, "IFRS");		fprintf(CHUNK, "RIdx");	four_word(4 + important_count*12);	four_word(important_count);		for (x = 0; x < chunk_count; x++)	{   if (chunk_important_array[x] == 1) {			type = chunk_id_array[x];			if ((strcmp(type, "Snd1")==0) || (strcmp(type, "Snd2")==0) || (strcmp(type, "Snd3"))==0)				type = "Snd ";			fprintf(CHUNK, "%s", type);			four_word(chunk_number_array[x]);			four_word(past_idx_offset + chunk_offset_array[x]);		}	}		for (x = 0; x <= max_resource_num; x++) {		picture_numbering[x] = -1;		sound_numbering[x] = -1;	}		pcount = 0; scount = 0;	for (x = 0; x < chunk_count; x++) {		type = chunk_id_array[x];		if (strcmp(type, "Pict")==0)		{   type = "PNG ";			picture_numbering[chunk_number_array[x]] = x;			pcount = pcount + 1;		}		if (strcmp(type, "Snd1")==0)		{   type = "AIFF";			sound_numbering[chunk_number_array[x]] = x;			scount = scount + 1;		}		if (strcmp(type, "Snd2")==0)		{   type = "MOD ";			sound_numbering[chunk_number_array[x]] = x;			scount = scount + 1;		}		if (strcmp(type, "Snd3")==0)		{   type = "SONG";			sound_numbering[chunk_number_array[x]] = x;			scount = scount + 1;		}		if (strcmp(type, "Exec")==0)		{   type = "ZCOD";		}			if (strcmp(type, "AIFF")!= 0)		{   fprintf(CHUNK, "%s", type);			four_word((chunk_size_array[x]) - 8);		}		chunk_filename = chunk_filename_array[x];printf("Read from %s\n", chunk_filename);			CHUNKSUB = fopen(chunk_filename, "rb");		if (CHUNKSUB == NULL) fatal("unable to read data from chunk_filename");		while (feof(CHUNKSUB) == 0) fputc(fgetc(CHUNKSUB), CHUNK);			fclose(CHUNKSUB);			if ((chunk_size_array[x] % 2) == 1) fputc(0, CHUNK);	}		fclose(CHUNK);	if (error_count > 0) {		printf("! Completed: %d error(s)\n", error_count);		exit(1);	}		printf("! Completed: size %d bytes ", iff_size);	printf("(%d pictures, %d sounds)\n", pcount, scount);	return(0);}